<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Aether's Blog</title>
    <description>Keep calm and carry on # this means to ignore newlines until &quot;baseurl:&quot;
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Sun, 23 Jun 2019 22:52:53 +0800</pubDate>
    <lastBuildDate>Sun, 23 Jun 2019 22:52:53 +0800</lastBuildDate>
    <generator>Jekyll v3.8.5</generator>
    
      <item>
        <title>Java一些有趣的小问题总结</title>
        <description>&lt;h2 id=&quot;java内部类访问局部变量必须声明为final&quot;&gt;Java内部类访问局部变量必须声明为final？&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
  String str = &quot;haha&quot;;
  // str = &quot;test&quot;;
  new Thread() {
    @Override
    public void run() {
      System.out.println(str);
    }
  }.start();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;以上代码能够通过编译正常运行，取消注释后编译不通过，报错如下：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Local variable str defined in an enclosing scope must be final or effectively
final&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;即Java内部类访问局部变量必须声明为final &lt;br /&gt; Java一开始没有报错是默认认为变量为final，若变量被修改过，则默认的假设不成立，Java报错。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;内部类的生命周期比局部变量的长，故定义str时JVM做了程序员看不到的操作：将str拷贝了一份给局部内部类，也就是说JVM在局部内部类中定义了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;final String str = &quot;haha&quot;;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;判断奇偶数&quot;&gt;判断奇偶数&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean isOdd(int i) {
return i % 2 == 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;x % 2 == 1&lt;/code&gt;的方式判断奇偶性对负数无效 &lt;br /&gt; Spotbugs指出：
If this code is intending to check for oddness, consider using &lt;code class=&quot;highlighter-rouge&quot;&gt;x &amp;amp; 1 == 1&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;x % 2 != 0&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean isOdd(int i) {
return (i &amp;amp; 1) == 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;字符串去哪儿了&quot;&gt;字符串去哪儿了？&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String a = &quot;a&quot;;
String b = &quot;a&quot;;
System.out.println(&quot;a and b: &quot; + a == b);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;’+’ 的运算优先级’==’ 高     ‘&amp;amp;&amp;amp;’ 优先级比 ‘||’ 高 &lt;br /&gt;&lt;/li&gt;
    &lt;li&gt;equals() 和 ==&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;integer为什么不相等&quot;&gt;Integer为什么不相等？&lt;/h2&gt;
&lt;h3 id=&quot;plan-a--使用constructor生成integer&quot;&gt;Plan A — 使用constructor生成Integer&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Integer a = new Integer(200);
Integer b = new Integer(200);
System.out.println(a == b);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;’==’ 判断是否指向同一对象&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;plan-b--使用valueof生成integer&quot;&gt;Plan B — 使用valueOf生成Integer&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Integer a = Integer.valueOf(200);
Integer b = Integer.valueOf(200);
System.out.println(a == b);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;plan-c--直接生成integer&quot;&gt;Plan C — 直接生成Integer&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Integer a = 200, b = 200;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Integer a = 200&lt;/code&gt;的时候，会自动调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Integer&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;valueOf()&lt;/code&gt;方法，故&lt;code class=&quot;highlighter-rouge&quot;&gt;Integer a = 200;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;Integer a = Integer.valueOf(200);&lt;/code&gt;等同&lt;/p&gt;

&lt;h3 id=&quot;从200变为2结果却不一样&quot;&gt;从200变为2，结果却不一样？&lt;/h3&gt;
&lt;h4 id=&quot;plan-b&quot;&gt;Plan B:&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Integer a = Integer.valueOf(2);
Integer b = Integer.valueOf(2);
System.out.println(a == b);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;plan-c&quot;&gt;Plan C:&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Integer a=2, b=2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;查看&lt;code class=&quot;highlighter-rouge&quot;&gt;valueOf()&lt;/code&gt;的源码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static Integer valueOf(int i) {
  if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
    return IntegerCache.cache[i + (-IntegerCache.low)];
  return new Integer(i);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;valueOf()&lt;/code&gt;在返回之前，会进行判断，判断当前i的值是否在 &lt;code class=&quot;highlighter-rouge&quot;&gt;-128~127&lt;/code&gt;之间。如果存在，则直接返回一个缓存的引用，不再重新开辟内存空间。
如果不存在，就创建一个新的对象&lt;code class=&quot;highlighter-rouge&quot;&gt;new Integer()&lt;/code&gt;。
&lt;br /&gt;
 &lt;code class=&quot;highlighter-rouge&quot;&gt;Integer&lt;/code&gt;存在缓存类&lt;code class=&quot;highlighter-rouge&quot;&gt;IntegerCache&lt;/code&gt;，而缓存类会在第一次加载时初始化一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Integer缓存数组&lt;/code&gt;，这个数组大小不是固定的，但是一定大于或等于256，覆盖范围为[-128,127]。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;integercache大小修改&quot;&gt;IntegerCache大小修改&lt;/h3&gt;

&lt;p&gt;cache的大小可以通过jvm指令修改：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-XX:AutoBoxCacheMax==&amp;lt;size&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;除&lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;以外的&lt;code class=&quot;highlighter-rouge&quot;&gt;所有基础数据类型对应的封装类型&lt;/code&gt;都实现了缓存。他们缓存都是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;valueOf()&lt;/code&gt;静态工厂完成的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;的位置影响结果&quot;&gt;++的位置影响结果&lt;/h3&gt;
&lt;p&gt;Test&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Integer a = new Integer(2);
Integer b = new Integer(2);
System.out.println(a++ == b++);
System.out.println(++a == ++b);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;false
true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;++a和++b是&lt;code class=&quot;highlighter-rouge&quot;&gt;autoboxing&lt;/code&gt;之后的结果 用到了cache&lt;br /&gt;
a++和b++是原来Integer的结果&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;被哪里捕捉了&quot;&gt;被哪里捕捉了?&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;try {
  try{
    FileInputStream p = new FileInputStream(&quot;a.txt&quot;);
  }catch(FileNotFoundException e) {
    System.out.println(&quot;a&quot;);
  }
}catch(Exception e) {
  System.out.println(&quot;b&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Output:
a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;try catch嵌套时若内层catch能捕获，则外层catch不执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;finally-vs-return&quot;&gt;finally vs return&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;boolean func() {
  try {
    return true;
  } finally {
    return false;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Result:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;类型参数命名惯例&quot;&gt;类型参数命名惯例&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;By convention, type parameter names are single, uppercase letters. This stands in sharp contrast to the variable naming conventions that you already know about, and with good reason: Without this convention, it would be difficult to tell the difference between a type variable and an ordinary class or interface name.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最常用的类型参数命名如下:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;E - Element (used extensively by the Java Collections Framework)&lt;/li&gt;
  &lt;li&gt;K - Key&lt;/li&gt;
  &lt;li&gt;N - Number&lt;/li&gt;
  &lt;li&gt;T - Type&lt;/li&gt;
  &lt;li&gt;V - Value&lt;/li&gt;
  &lt;li&gt;S,U,V etc. - 2nd, 3rd, 4th types&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;调用了哪个方法&quot;&gt;调用了哪个方法？&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class A {
  void foo() {
    this.bar();
  }
  void bar() {
    print(&quot;A.bar&quot;);
  }
}

class B extends A {
  void foo() {
    super.foo();
  }
  void bar() {
    print(&quot;B.bar&quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;B.bar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;B中的&lt;code class=&quot;highlighter-rouge&quot;&gt;foo()&lt;/code&gt;override了A中的&lt;code class=&quot;highlighter-rouge&quot;&gt;foo()&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Overridden的实例方法被调用的是子类型中的。&lt;br /&gt;区分于hidden的情况（hide适用于field和静态方法）
hidden的静态方法被调用的是哪一个取决于它被调用的位置（子类型还是父类型）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Test {
  public static void main(String[] args) {
    new B().foo();
  }
}

class A {
  void foo() {
    barStatic();
  }
  static void barStatic() {
    System.out.println(&quot;A.barStatic&quot;);
  }
}

class B extends A {
  void foo() {
    super.foo();
  }
  static void barStatic() {
    System.out.println(&quot;B.barStatic&quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A.barStatic
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;返回值协变&quot;&gt;返回值协变&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface A {
  public C build(...);
}
class B implements A {
  public D build(...) {
    ...
  }
}
其中D是C的子类型

客户端：
C c = new B().create();
此时c的运行时类型其实是D

接口和类之间的override同样可以covariance。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;catch-exception-的顺序问题&quot;&gt;catch Exception 的顺序问题&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;try {
  FileInputStream p = new FileInputStream(&quot;a.txt&quot;);
}catch(Exception e) {
  System.out.println(&quot;exception&quot;);
}catch(FileNotFoundException e) {
  System.out.println(&quot;file not found exception&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;Unreachable catch block for FileNotFoundException. It is already handled by the catch block for Exception&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sun, 23 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/Java%E7%BB%86%E8%8A%82%E6%80%BB%E7%BB%93.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/Java%E7%BB%86%E8%8A%82%E6%80%BB%E7%BB%93.html</guid>
        
        <category>SOFTWARE-CONSTRUCTION</category>
        
        <category>JAVA</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>Java中-able总结</title>
        <description>&lt;h2 id=&quot;java中-able总结&quot;&gt;Java中-able总结&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Comparable &amp;amp; Comparator&lt;/li&gt;
  &lt;li&gt;Iterable &amp;amp; Iterator&lt;/li&gt;
  &lt;li&gt;Observable &amp;amp; Observer&lt;/li&gt;
  &lt;li&gt;Throwable&lt;/li&gt;
  &lt;li&gt;Cloneable&lt;/li&gt;
  &lt;li&gt;Runnable&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;comparable--comparator&quot;&gt;Comparable &amp;amp; Comparator&lt;/h3&gt;

&lt;h4 id=&quot;comparable&quot;&gt;Comparable&lt;/h4&gt;
&lt;p&gt;需override&lt;code class=&quot;highlighter-rouge&quot;&gt;compareTo()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Person implements Comparable&amp;lt;Person&amp;gt; {
   @Override
   public int compareTo(Person o) {
     if (...) return -1;
     else if (...) return 1;
     else return 0;
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;comparator&quot;&gt;Comparator&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparator&lt;/code&gt;是策略模式&lt;code class=&quot;highlighter-rouge&quot;&gt;strategy design pattern&lt;/code&gt;，可使用不同的Comparator对象实现不同策略的排序。
需override&lt;code class=&quot;highlighter-rouge&quot;&gt;compare()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Cmp implements Comparator {
  @Override
  public int compare(Object arg0, Object arg1) {
    Person a = (Person) arg0;
    Person b = (Person) arg1;
    if (...) return -1;
    else if (...) return 1;
    else return 0;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;调用方法：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Person[] p = new Person[4];
Arrays.sort(p);//默认排序
Arrays.sort(p, new Cmp());//自定义排序
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;summary&quot;&gt;Summary&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;顾名思义，某个class实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparable&lt;/code&gt;可以使该class的对象可比较：&lt;code class=&quot;highlighter-rouge&quot;&gt;a.compareTo(b)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparator&lt;/code&gt;为比较器和一种比较策略，内部需override&lt;code class=&quot;highlighter-rouge&quot;&gt;compare()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;iterable--iterator&quot;&gt;Iterable &amp;amp; Iterator&lt;/h3&gt;

&lt;h4 id=&quot;iterator&quot;&gt;Iterator&lt;/h4&gt;
&lt;p&gt;Iterator的定义：包含&lt;code class=&quot;highlighter-rouge&quot;&gt;hasNext()&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;next()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;remove()&lt;/code&gt;方法。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Iterator {  
　　boolean hasNext();  
　　Object next();  
　　void remove();  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Iterator的使用：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Iterator iter = l.iterator();
while(iter.hasNext()){
    String str = (String) iter.next();
    System.out.println(str);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;iterable&quot;&gt;Iterable&lt;/h4&gt;

&lt;p&gt;Iterabler的定义：包含&lt;code class=&quot;highlighter-rouge&quot;&gt;iterator()&lt;/code&gt;方法。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Iterable&amp;lt;T&amp;gt; {
  Iterator&amp;lt;T&amp;gt; iterator();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Iterable的使用：override&lt;code class=&quot;highlighter-rouge&quot;&gt;iterator()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ArrayMap&amp;lt;K, V&amp;gt; implements Iterable&amp;lt;K&amp;gt; {
  @Override
  public Iterator&amp;lt;K&amp;gt; iterator() {
      return new KeyIterator();
  }
}

public class KeyIterator implements Iterator&amp;lt;K&amp;gt; {
  @Override
  public boolean hasNext() {
      ...
  }
  @Override
  public K next() {
      ...
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;observable--observer&quot;&gt;Observable &amp;amp; Observer&lt;/h3&gt;

&lt;h4 id=&quot;observer&quot;&gt;Observer&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Observer {
  void update(Observable o, Object arg);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;observerable&quot;&gt;Observerable&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class NumObservable extends Observable {
  private int data = 0;
  public int getData() {
     return data;
  }
  public void setData(int i) {
     data = i;
     setChanged();
     notifyObservers();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;被观察者&lt;code class=&quot;highlighter-rouge&quot;&gt;NumObserable&lt;/code&gt;执行了&lt;code class=&quot;highlighter-rouge&quot;&gt;notifyObservers()&lt;/code&gt;后，观察者执行&lt;code class=&quot;highlighter-rouge&quot;&gt;update()&lt;/code&gt;方法。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class NumObserver implements Observer {

  @Override
  public void update(Observable o, Object arg) {
    NumsObservable myObserable = (NumsObservable) o;
    System.out.println(&quot;Data has changed to &quot; + myObserable.getData());
  }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;throwable&quot;&gt;Throwable&lt;/h3&gt;
&lt;p&gt;This is a &lt;strong&gt;class&lt;/strong&gt;, not interface.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyException_another extends Throwable {
   private static final long serialVersionUID = 1L;
   public MyException_another() {
     super();
   }
   public MyException_another(String msg) {
     super(msg);
   }
   public MyException_another(String msg, Throwable cause) {
     super(msg, cause);
   }
   public MyException_another(Throwable cause) {
     super(cause);
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;cloneable&quot;&gt;Cloneable&lt;/h3&gt;
&lt;p&gt;需重写&lt;code class=&quot;highlighter-rouge&quot;&gt;clone()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Test implements Cloneable {
  @Override
  protected Object clone() throws CloneNotSupportedException {
      ...
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;runnable&quot;&gt;Runnable&lt;/h3&gt;

&lt;p&gt;需重写&lt;code class=&quot;highlighter-rouge&quot;&gt;run()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyThread1 implements Runnable {
  @Override
  public synchronized void  run() {
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 20 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/interface%E6%80%BB%E7%BB%93.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/interface%E6%80%BB%E7%BB%93.html</guid>
        
        <category>CODE</category>
        
        <category>SOFTWARECONSTRUCTION</category>
        
        <category>JAVA</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>面向性能的构造技术</title>
        <description>&lt;h2 id=&quot;metrics&quot;&gt;Metrics&lt;/h2&gt;
&lt;h3 id=&quot;time-performance&quot;&gt;Time performance&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;get execution time&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; System.currentTimeMillis()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Basic statements&lt;/li&gt;
  &lt;li&gt;Algorithms&lt;/li&gt;
  &lt;li&gt;Data structure&lt;/li&gt;
  &lt;li&gt;I/O (file, database, network communication, etc)&lt;/li&gt;
  &lt;li&gt;Concurrency / multi-thread / lock
    &lt;h3 id=&quot;space-performance&quot;&gt;Space performance&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;Get memory consumption
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Get the Java runtime
Runtime runtime = Runtime.getRuntime();
// Run the garbage collector
runtime.gc();
// Calculate the used memory
long memory = runtime.totalMemory() - runtime.freeMemory();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Algorithms&lt;/li&gt;
  &lt;li&gt;Data structure&lt;/li&gt;
  &lt;li&gt;Memory allocation&lt;/li&gt;
  &lt;li&gt;Garbage collection&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;memory-performance-and-garbage-collection&quot;&gt;Memory Performance and Garbage Collection&lt;/h2&gt;
&lt;h3 id=&quot;memory-management-in-os-and-application-level&quot;&gt;Memory Management in OS and Application Level&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;memory allocation 内存分配&lt;/li&gt;
  &lt;li&gt;garbage collection 垃圾回收&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;object-model-内存对象模型&quot;&gt;Object Model 内存对象模型&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Create a new object x&lt;/li&gt;
  &lt;li&gt;Attach it to the reference x;&lt;/li&gt;
  &lt;li&gt;Initialize its fields.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;three-modes-of-object-management&quot;&gt;Three modes of object management&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Static mode ——在编译阶段就已经确定好了内存分配&lt;/li&gt;
  &lt;li&gt;Dynamic allocation
    &lt;ul&gt;
      &lt;li&gt;Stack-based mode
        &lt;ul&gt;
          &lt;li&gt;存储方法调和局部变量&lt;/li&gt;
          &lt;li&gt;多线程之间传递数据，是通过复制而非引用局部的基本数据类型&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Heap-based mode  (free mode)
        &lt;ul&gt;
          &lt;li&gt;在一块内存里分为多个小块，每块包含 一个对象，或者未被占用&lt;/li&gt;
          &lt;li&gt;所有对象&lt;/li&gt;
          &lt;li&gt;即使是局部变量的object，也是在堆上创建&lt;/li&gt;
          &lt;li&gt;堆上创建的对象可被所有线程共享引用&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;java-memory-model&quot;&gt;Java Memory Model&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Thread Stack — All local variables of primitive types&lt;/li&gt;
  &lt;li&gt;Heap — All objects&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;memory-structure-of-jvm&quot;&gt;Memory Structure of JVM&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Stacks
    &lt;ul&gt;
      &lt;li&gt;Reference/Local variable&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Heap
    &lt;ul&gt;
      &lt;li&gt;Object/Value&lt;/li&gt;
      &lt;li&gt;An object’s primitive member variables&lt;/li&gt;
      &lt;li&gt;a member variable is a reference to an objectf&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Native Stacks 本地方法栈
    &lt;ul&gt;
      &lt;li&gt;manage native methods (coded in C) used by JVM&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Program Counter Register (PC)
    &lt;ul&gt;
      &lt;li&gt;代码行号指示器，用于指示， 跳转下一条需要执行的命令&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Method Area
    &lt;ul&gt;
      &lt;li&gt;用于存储被VM加载的类信息、常量、静态变量等 class Static variable&lt;/li&gt;
      &lt;li&gt;HotSpot JVM中用Permanent Area (Perm)实现该区域，并作为heap的一部分&lt;/li&gt;
      &lt;li&gt;Java 8之后改名为Metaspace (使用native memory)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;garbage-collection&quot;&gt;Garbage Collection&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;static modes
无需进行内存回收:所有都是已确定的&lt;/li&gt;
  &lt;li&gt;stack-based modes
在栈上进行内存空间回收:按block(某个方法)整体进行&lt;/li&gt;
  &lt;li&gt;heap-based (free) modes
    &lt;ul&gt;
      &lt;li&gt;Reachable Objects vs. Unreachable Objects — Live vs. Dead &lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;从root对象开始进行有向图的搜索，将图分为root可达部分和root不可达部分 &lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;roots&lt;/strong&gt; 包括：&lt;br /&gt;
1) Words in the static area 静态区域的数据&lt;br /&gt;
2) Registers 寄存器&lt;br /&gt;
3) Words on the execution stack that point into the heap. 目前的执行栈中的数据所指向的内存对象&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;help-the-gc-that-you-are-finished-with-an-object&quot;&gt;Help the GC that you are finished with an object&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;r = new FileReader(filename)
// use the reader
...
reader.close();
reader = null;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;without-automatic-gc&quot;&gt;Without Automatic GC&lt;/h4&gt;
&lt;p&gt;内存泄露，很多dead objects仍占据着内存空间 &lt;br /&gt;
原本live的对象却被回收了 (Dangling Pointers 悬空指针)，导致程序执行失效。&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;basic-algorithms-of-garbage-collection&quot;&gt;Basic Algorithms of Garbage Collection&lt;/h2&gt;
&lt;h3 id=&quot;reference-counting-引用计数&quot;&gt;Reference counting 引用计数&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;为每个object存储一个计数RC，当有其他 reference指向它时，RC++;当其他reference与其断开时，RC–;如 果RC==0，则回收它 (及其所有指向的object)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Advantages&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;简单&lt;/li&gt;
  &lt;li&gt;计算代价分散&lt;/li&gt;
  &lt;li&gt;“幽灵时间”短-&amp;gt;0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Disadvantages&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;不全面(容易漏掉循环引用的对象cyclic)&lt;/li&gt;
  &lt;li&gt;并发支持较弱&lt;/li&gt;
  &lt;li&gt;占用额外内存空间等&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mark-sweep-标记-清除&quot;&gt;Mark-Sweep 标记-清除&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;标记-清除:为每个object设定状态位(live/dead)并记录，即mark阶段;将标记为dead的对象进行清理，即sweep阶段。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Disadvantages&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;需要停止程序执行来Mark和Sweep，导致幽灵时间过长，也影响程序本身的性能&lt;/li&gt;
  &lt;li&gt;碎片化&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mark-compact-标记-整理&quot;&gt;Mark-Compact 标记-整理&lt;/h3&gt;
&lt;p&gt;Advantages&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;避免碎片化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Disadvantages&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;时间消耗太长，影响程序本身&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fragmentation-and-copying-复制&quot;&gt;Fragmentation and Copying 复制&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;该GC策略与mark-compact的区别在于:不是在同一个区域内进行整理，而是将live对象全部复制到另一个区域。&lt;br /&gt; 将堆分为两部分 Fromspace and Tospace&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;garbage-collection-in-jvm&quot;&gt;Garbage Collection in JVM&lt;/h2&gt;
&lt;p&gt;Java GC将堆分为不同的区域，各区域采用不同的GC策略，以提高GC的效率&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-verbose:gc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;three-major-space-in-hotspot-vm-sun-jvm&quot;&gt;Three major space in HotSpot VM (Sun JVM)&lt;/h3&gt;
&lt;h4 id=&quot;young-generation&quot;&gt;young generation&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Eden&lt;/li&gt;
  &lt;li&gt;From survivor space&lt;/li&gt;
  &lt;li&gt;To survivor space&lt;/li&gt;
  &lt;li&gt;只有一小部分对象可较长时间存活，故采用&lt;strong&gt;copy&lt;/strong&gt;算法减少GC代价&lt;/li&gt;
  &lt;li&gt;使用&lt;strong&gt;minor GC&lt;/strong&gt;进行垃圾收集&lt;/li&gt;
  &lt;li&gt;Minor GC所需时间较短&lt;/li&gt;
  &lt;li&gt;如果历经多次minor GC仍存活下来，将其copy到old generation&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;old-generation-space-tenured&quot;&gt;old generation space (tenured)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这里的对象有很高的幸存度，使用&lt;strong&gt;Mark-Sweep&lt;/strong&gt;或&lt;strong&gt;Mark-Compact&lt;/strong&gt;算法&lt;/li&gt;
  &lt;li&gt;启动&lt;strong&gt;full GC&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Old generation满，意味着无法进行下一次minor GC&lt;/li&gt;
  &lt;li&gt;Minor GC和full GC独立进行，减小代价&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;permanent-generation-space-perm&quot;&gt;Permanent generation space (perm)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;当perm generation满了之后，无法存储更多的元数据，也启动full GC&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;只有当某个区域不能再为对象分配内存时(满)才启动GC
&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.OutOfMemoryError&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;garbage-collection-tuning-in-jvm&quot;&gt;Garbage Collection Tuning in JVM&lt;/h2&gt;
&lt;h3 id=&quot;specifying-vm-heap-size-确定堆的大小&quot;&gt;Specifying VM heap size 确定堆的大小&lt;/h3&gt;
&lt;h4 id=&quot;控制young-generation的大小&quot;&gt;控制Young generation的大小&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;-XX: NewSize=&lt;n&gt;[g|m|k]&lt;/n&gt;&lt;/li&gt;
  &lt;li&gt;-XX: MaxNewSize=&lt;n&gt;[g|m|k]&lt;/n&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-Xmn&lt;n&gt;[g|m|k]
-三个参数依次为最小值、最大值和固定值。&lt;/n&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;-Xms and -Xmx 初始和最大的heap尺寸
heap尺寸变化时需 要full GC&lt;/li&gt;
  &lt;li&gt;-XX:MetaspaceSize -XX:MaxMetaspaceSize for Java 8 and later&lt;/li&gt;
  &lt;li&gt;-XX:SurvivorRatio=&lt;n&gt;&lt;/n&gt;&lt;/li&gt;
  &lt;li&gt;-XX:NewRatio=&lt;n&gt; --- young and old generation is 1:n&lt;/n&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;old generation的尺寸不需要设置，根据其他各参数的取值可计算得到&lt;/p&gt;

&lt;h3 id=&quot;choosing-a-garbage-collection-scheme-选择gc模式&quot;&gt;Choosing a garbage collection scheme 选择GC模式&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;-XX:+UseSerialGC：使用单线程GC。&lt;/li&gt;
  &lt;li&gt;-XX:+UseParallelGC：对MinorGC使用多线程进行回收，但对MajorGC仍采用单线程。&lt;/li&gt;
  &lt;li&gt;-XX:+UseConcMarkSweepGC：与程序的运行同步地进行垃圾回收，回收时会短暂地暂停程序。&lt;/li&gt;
  &lt;li&gt;-XX:+UseTrainGC：每次MinorGC回收一部分老年代对象，以尝试最小化MajorGC的长时暂停。
    &lt;h4 id=&quot;garbage-first-collector&quot;&gt;Garbage-First collector&lt;/h4&gt;
    &lt;blockquote&gt;
      &lt;p&gt;designed for heap sizes greater than 4GB. It divides the heap size into regions. After the marking phase is complete, G1 collects the region with lesser live data, which usually yields a large amount of free space. So G1 collects these regions first.
&lt;br /&gt;Default in Java 9.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Automatically logging low memory conditions 自动记录内存将要不足的情况&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;-Xloggc:../../logs/gc-console.log&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Manually requesting garbage collection 手工请求GC&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;System.gc()&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;io-and-algorithm-performance&quot;&gt;I/O and Algorithm Performance&lt;/h2&gt;
&lt;h3 id=&quot;buffer对数据进行缓冲&quot;&gt;Buffer：对数据进行缓冲&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;BufferedReader&lt;/li&gt;
  &lt;li&gt;BufferedWriter&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;stream将数据视作流&quot;&gt;Stream：将数据视作流&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;FileInputStream&lt;/li&gt;
  &lt;li&gt;FileOutputStream&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nionew-io&quot;&gt;NIO：New I/O&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Buffers（包括CharBuffer、ByteBuffer、IntBuffer、DoubleBuffer等）&lt;/li&gt;
  &lt;li&gt;Channels（包括FileChannel、SockerChannel等，可向Buffer提供数据）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lamda&quot;&gt;Lamda&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Files.lines(Paths.get(args[0])).forEach(System.out::println);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;dynamic-program-analysis-methods-and-tools&quot;&gt;Dynamic Program Analysis Methods and Tools&lt;/h2&gt;
&lt;h3 id=&quot;80-20-rule&quot;&gt;80-20 rule&lt;/h3&gt;
&lt;p&gt;20% of program responsible for 80% of execution time&lt;/p&gt;
&lt;h3 id=&quot;dynamic-program-analysis&quot;&gt;Dynamic Program Analysis&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Program Hot Spots — 每个程序实体 (语句、分支、路径、方法等)的执行概率/频度是多少&lt;/li&gt;
  &lt;li&gt;Path profiling&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;profiling-approaches&quot;&gt;Profiling Approaches&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Insertion/Instrumentation 代码注入/代码插入&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在原始程序中加入某些语句来收集运行时数据，这些语句不改变原程序的语义，但对原程序的性能有了轻微变化&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Sampling: observation of behavior 采样&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以特定的频率观察程序执行的特定时刻所展现出的行为与状态&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Instrumented virtual machine 借助于虚拟机获取程序性能数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;program-profiling-tools-in-java&quot;&gt;Program Profiling Tools in Java&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Command-line profiling tools
    &lt;ul&gt;
      &lt;li&gt;jhat — 在Web浏览器中查看heap dump文件的内容&lt;/li&gt;
      &lt;li&gt;jmap — jmap -dump 生成 java heap dump&lt;/li&gt;
      &lt;li&gt;jstat&lt;/li&gt;
      &lt;li&gt;jstack — 打印 stack traces&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;JConsole&lt;/li&gt;
  &lt;li&gt;Visual VM&lt;/li&gt;
  &lt;li&gt;Memory Analyzer (MAT) — 显示堆转储的内容分析&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;code-tuning-for-performance-optimization&quot;&gt;Code Tuning for Performance Optimization&lt;/h2&gt;
&lt;h3 id=&quot;java代码调优的设计模式&quot;&gt;Java代码调优的设计模式&lt;/h3&gt;
&lt;h4 id=&quot;singleton-pattern&quot;&gt;Singleton Pattern&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;逻辑上仅能存在唯一一个实例，为了防止多个该对象实例被创建，将构造方法设为私有，并提供获取该类唯一实例的方法（ &lt;code class=&quot;highlighter-rouge&quot;&gt;getInstance()&lt;/code&gt; ）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;static final instance
    &lt;blockquote&gt;
      &lt;p&gt;设置静态变量来存储单一实例对象&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;private constructor
    &lt;blockquote&gt;
      &lt;p&gt;将构造器设置为private，从而client无法new &lt;br /&gt;  在构造器中new新实例&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;static getInstance()
    &lt;blockquote&gt;
      &lt;p&gt;提供静态方法来获取单一实例对象 &lt;br /&gt;  进一步提升性能:在需要的时候再new，而非提前构造&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;flyweight-pattern&quot;&gt;Flyweight Pattern&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;当某对象由大量对象组成，而部分Flyweight对象可被共享以减少资源消耗时，可创建一个工厂类以方便外界获得可被共享的对象，对于目前不存在的ConcreteFlyweight对象，工厂类会创建之，而对于已存在的ConcreteFlyweight对象，工厂类会直接返回之。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;固定 — 内部rep&lt;/li&gt;
  &lt;li&gt;可变 — 外部特征&lt;/li&gt;
  &lt;li&gt;Immutable&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;prototype-pattern-cloneable&quot;&gt;Prototype Pattern /cloneable&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;当需要客户端指定要创建的对象的类型，且之后需创建的对象与先前指定的完全相同时，可通过给出第一个对象（称为原型对象）以指明之后所有对象的类型，之后所有对象通过复制第一个对象来创建。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;implement &lt;code class=&quot;highlighter-rouge&quot;&gt;Cloneable&lt;/code&gt;, override &lt;code class=&quot;highlighter-rouge&quot;&gt;clone()&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;reference copy — shallow copy&lt;/li&gt;
  &lt;li&gt;object copy — deep copy&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;object-pool-pattern&quot;&gt;Object Pool Pattern&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;当某类对象（图中为Object类对象）的创建代价极大，而该类对象可以以较小的代价被重复利用时，可以预先建立一个对象池用于保存该类对象。对象池中可预先创建几个对象等待使用，使用完的对象会回到对象池中被重新初始化并被再利用，减少对象的创建操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;代价:原本可被GC的对象，现在要留在pool中，导致内存浪费 —— 用空间换时间&lt;/p&gt;
&lt;h4 id=&quot;canonicalizing-objects&quot;&gt;Canonicalizing Objects&lt;/h4&gt;

&lt;h3 id=&quot;string-constant-pool&quot;&gt;String Constant Pool&lt;/h3&gt;
&lt;p&gt;堆中包含字符串对象引用的特殊内存区域&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String s = “java”;
String s = new String(“java”);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 20 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/Performance.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/Performance.html</guid>
        
        <category>CODE</category>
        
        <category>SOFTWARECONSTRUCTION</category>
        
        <category>JAVA</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>软件构造课程总结——并行与分布式程序</title>
        <description>&lt;h2 id=&quot;concurrency&quot;&gt;Concurrency&lt;/h2&gt;
&lt;h3 id=&quot;two-models-for-concurrent-programming&quot;&gt;Two Models for Concurrent Programming&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Shared memory — 并发模块通过在内存中读写共享对象进行交互。&lt;/li&gt;
  &lt;li&gt;Message passing — sending messages to each other through a communication channel. Modules send off messages, and incoming messages to each module are queued up for handling.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;应用&quot;&gt;应用&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;网络上的两台计算机通过网络连接通讯&lt;/li&gt;
  &lt;li&gt;浏览器和Web服务器，A请求页面，B发送页面数据给A&lt;/li&gt;
  &lt;li&gt;即时通讯软件的客户端和服务器&lt;/li&gt;
  &lt;li&gt;同一台计算机上的两个程序通过管道连接进行通讯&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;process--thread&quot;&gt;Process &amp;amp; Thread&lt;/h2&gt;
&lt;h3 id=&quot;process&quot;&gt;Process&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在同一机器上独立于其它进程的一个运行中程序的实例。它拥有自己独立的内存空间。可视为一台虚拟机。&lt;/li&gt;
  &lt;li&gt;拥有整台计算机的资源&lt;/li&gt;
  &lt;li&gt;私有空间 彼此隔离 不共享内存&lt;/li&gt;
  &lt;li&gt;通过消息传递进行协作&lt;/li&gt;
  &lt;li&gt;JVM通常运行单一进程，但也可以创建新的进程&lt;/li&gt;
  &lt;li&gt;共享可变对象时需要同步&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;thread&quot;&gt;Thread&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;一个运行中程序的控制轨迹，每个线程在程序中某个位置执行，拥有自己独立的运行时栈。可视为一个虚拟处理器。&lt;/li&gt;
  &lt;li&gt;共享内存 消息队列&lt;/li&gt;
  &lt;li&gt;轻量级&lt;/li&gt;
  &lt;li&gt;共享可变对象时需要同步&lt;/li&gt;
  &lt;li&gt;unsafe to kill&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;new-thread&quot;&gt;new Thread&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;(Seldom used) Subclassing Thread.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyThread extends Thread {
@Override
public void run() {
  ...
}
}
(new MyThread()).start();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(new MyThread()).run();可运行，未启动线程
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;(More generally used) 从Runnable接口构造Thread对象
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new Thread(new Runnable() {
 public void run() {
     System.out.println(&quot;Hello&quot;);
 }
}).start();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyThread implements Runnable {
@Override
public void run() {
  ...
}
(new Thread(new MyThread())).start();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;heisenbugs&quot;&gt;Heisenbugs&lt;/h3&gt;
&lt;p&gt;Nondeterministic and hard to reproduce &lt;br /&gt;
A heisenbug may even disappear when you try to look at it with println or debugger&lt;/p&gt;
&lt;h3 id=&quot;bohrbugs&quot;&gt;Bohrbugs&lt;/h3&gt;
&lt;p&gt;Showing up repeatedly whenever you look at it.&lt;/p&gt;
&lt;h2 id=&quot;interleaving-and-race-condition&quot;&gt;Interleaving and Race Condition&lt;/h2&gt;
&lt;h3 id=&quot;time-slicing&quot;&gt;Time slicing&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在单核计算机中，每一时刻仅有一个线程在实际运行。单个核心的运行时间通过操作系统的特性被各个进程和线程共享，这种行为称为时间分片。&lt;/li&gt;
  &lt;li&gt;在多核计算机中，当线程数大于核心数时，也通过时间分片来模拟线程并行运行。&lt;/li&gt;
  &lt;li&gt;时间切片不可预测、不确定，这意味着线程可以随时暂停或恢复&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;shared-memory-among-threads&quot;&gt;Shared Memory among Threads&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Interleaving 交叉存取 — 当两线程并行运行时，底层指令可能交错运行&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;race-condition&quot;&gt;Race Condition&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;The correctness of the program (the satisfaction of postconditions and invariants) depends on the relative timing of events in concurrent computations A and B. When this happens, we say “A is in a race with B.”&lt;/li&gt;
  &lt;li&gt;单行、单条语句都未必是原子的。是否原子由JVM确定&lt;/li&gt;
  &lt;li&gt;also called “Thread Interference”&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;some-operations-for-interfering-automatic-interleaving-of-threads&quot;&gt;Some operations for interfering automatic interleaving of threads&lt;/h2&gt;
&lt;h3 id=&quot;threadsleep&quot;&gt;Thread.sleep()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;不会失去对现有monitor锁的所有权&lt;/li&gt;
  &lt;li&gt;在sleep()的时候检测是否收到别人的中断信号, catch(IntterruptedException e)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;threadinterrupt&quot;&gt;Thread.interrupt()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;t.interrupt()&lt;/li&gt;
  &lt;li&gt;t.isInterrupted()
-正常运行期间，即使受到中断信号也不理会&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;threadyield-避免使用&quot;&gt;Thread.yield() (避免使用)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;线程会告诉调度器可以放弃CPU的占用权, 从而可能引起调度器唤醒其他线程&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;threadjoin&quot;&gt;Thread.join()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;让当前线程保持执行，直到其执行结束&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;objectwait&quot;&gt;object.wait()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;使用前提为线程已获得被调用对象的对象锁。当前线程放弃对象锁并进入等待状态，直到其它获得该对象锁的线程对该对象调用notify()或notifyAll()方法。当前线程被通知或被中断时，尝试重新获得锁并继续运行。若被中断，InterruptedException将在获得对象锁之后抛出。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;thread-safety&quot;&gt;Thread Safety&lt;/h2&gt;
&lt;h3 id=&quot;confinement&quot;&gt;Confinement&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Don’t share: isolate mutable state in individual threads&lt;/li&gt;
  &lt;li&gt;将可变数据限制在单一线程内部，避免竞争&lt;/li&gt;
  &lt;li&gt;不允许任何线程直接读写该数据&lt;/li&gt;
  &lt;li&gt;避免全局变量 如Singleton设计模式 两个线程同时调用getInstance()违背设计&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;immutability&quot;&gt;Immutability&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Don’t mutate: share only immutable state&lt;/li&gt;
  &lt;li&gt;共享不可变的引用和数据类型&lt;/li&gt;
  &lt;li&gt;如果使用了beneficent mutation还是要加锁&lt;/li&gt;
  &lt;li&gt;不含mutator方法&lt;/li&gt;
  &lt;li&gt;所有字段必须被private final修饰&lt;/li&gt;
  &lt;li&gt;子类不可重写方法&lt;/li&gt;
  &lt;li&gt;没有表示泄露&lt;/li&gt;
  &lt;li&gt;表示中的可变对象不得变化&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;using-threadsafe-data-types&quot;&gt;Using Threadsafe Data Types&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Threadsafe Collections&lt;/li&gt;
  &lt;li&gt;private static Map&amp;lt;Integer,Boolean&amp;gt; cache = Collections.synchronizedMap(new HashMap&amp;lt;&amp;gt;());&lt;/li&gt;
  &lt;li&gt;多个操作间不保证安全 如(!list.isEmpty()) list.get(0)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;locks-and-synchronization&quot;&gt;Locks and Synchronization&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在使用synchronizedMap(hashMap)之后，不要再把参数hashMap共享给其他线程，不要保留别名，一定要彻底销毁&lt;/li&gt;
  &lt;li&gt;即使在线程安全的集合类上，使用iterator也是不安全的（除非使用lock机制）&lt;/li&gt;
  &lt;li&gt;即使是线程安全的collection类，仍可能产生竞争&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;volatile&quot;&gt;Volatile&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;volatile也可保证基本类型变量变化对于所有线程的可见性（同步缓存），但不一定保证操作的原子性。&lt;/li&gt;
  &lt;li&gt;当且仅当对volatile修饰的变量进行的修改与任何变量（包括自身）的值无关时，其才是线程安全的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;线程安全策略撰写&quot;&gt;线程安全策略撰写&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;采取了四种方法中的哪一种&lt;/li&gt;
  &lt;li&gt;如果是后两种，还需考虑对数据的访问 都是原子的，不存在interleaving&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;confinement-1&quot;&gt;Confinement&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;局限访问策略通常不适用于仅仅讨论一个数据类型的情况，因为你需要知道系统中存在哪些线程，每个线程可访问哪些对象。&lt;/li&gt;
  &lt;li&gt;若访问该数据类型的线程均由自身创建，则可讨论这些线程间如何保持访问的局限性&lt;/li&gt;
  &lt;li&gt;若线程来自于外部，则无法讨论&lt;/li&gt;
  &lt;li&gt;通常在将系统作为一个整体，讨论一些模块或数据类型不需要线程安全的原因时，会从设计的角度论证线程间不会共享数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;immutability-1&quot;&gt;Immutability&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;说明对象中数据为何能够保持不可变性即可&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;using-threadsafe-data-types-1&quot;&gt;Using Threadsafe Data Types&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;表明该数据类型的所有原子操作都被恰当地设计，使得该数据类型依赖的不变式不受原子操作的交错执行影响。&lt;/li&gt;
  &lt;li&gt;nodes和edges举例&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private final Set&amp;lt;Node&amp;gt; nodes = Collections.synchronizedSet(new HashSet&amp;lt;&amp;gt;());
private final Map&amp;lt;Node,Set&amp;lt;Node&amp;gt;&amp;gt; edges = Collections.synchronizedMap(new HashMap&amp;lt;&amp;gt;());
// 表示不变式：
// 对于所有满足y是edges.get(x)的成员的二元组x和y，x,y都是nodes的成员。
该类是线程安全的，因为：nodes和edges都声明为final，因此它们都是不可变的且是线程安全的。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;nodes和edges都指向线程安全的Set和Map数据类型。
该论证仅防止了某些竞争条件，但不是全部。由于该类的表示不变式中要求了nodes与edges成员间的关系，因此还应论证两者成员的改变应当是同时的、原子的。若该点无法证明，则可以构造竞争条件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;locks-and-synchronization-1&quot;&gt;Locks and Synchronization&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;表明该数据类型的所有原子操作都被恰当地设计，使得该数据类型依赖的不变式不受原子操作的交错执行影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;locks-and-synchronization-2&quot;&gt;Locks and Synchronization&lt;/h2&gt;
&lt;h3 id=&quot;monitor模式adt所有方法都是互斥访问&quot;&gt;Monitor模式:ADT所有方法都是互斥访问&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;reads must be guarded as well as writes&lt;/li&gt;
  &lt;li&gt;public synchronized void fun(){…} == synchronized(this)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fine-grained-synchronization&quot;&gt;fine-grained synchronization.&lt;/h3&gt;
&lt;p&gt;synchronized(object)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public synchronized Constructor(){
  ...
} // wrong
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;用ADT自己做lock&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lock&quot;&gt;Lock&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Object lock = new Object();
synchronized (lock) {
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;liveness&quot;&gt;Liveness&lt;/h2&gt;
&lt;h3 id=&quot;deadlock&quot;&gt;Deadlock&lt;/h3&gt;
&lt;p&gt;多个线程竞争lock，相互等待对方释放lock&lt;/p&gt;

&lt;h4 id=&quot;解决方案&quot;&gt;解决方案：&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;两线程均按顺序征用锁-两个线程均先获得A锁再获得B锁
    &lt;ul&gt;
      &lt;li&gt;缺点1:不是模块化的——代码必须知道系统中的所有锁，或者至少知道子系统中的所有锁&lt;/li&gt;
      &lt;li&gt;缺点2:代码可能很难或不可能在获取第一个锁之前准确地知道它需要哪些锁 &lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;粗粒度的lock
    &lt;ul&gt;
      &lt;li&gt;缺点：性能下降&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;starvation&quot;&gt;Starvation&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;因为其他线程lock时间太长，一个线程长时间无法获取其所需的资源访问权(lock)，导致无法往下进行&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;livelock&quot;&gt;Livelock&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;两线程的行为互相由对方的行为决定（通常是为了避免死锁），线程没有锁死，仍在正常运行，但无法正常工作。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 18 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/Concurrent-and-Distributed-Programming.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/Concurrent-and-Distributed-Programming.html</guid>
        
        <category>SOFTWARE-CONSTRUCTION</category>
        
        <category>JAVA</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>Software Construction Summary 3</title>
        <description>&lt;h2 id=&quot;equality-in-adt-and-oop&quot;&gt;Equality in ADT and OOP&lt;/h2&gt;

&lt;h3 id=&quot;equals&quot;&gt;equals&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;equality: 自反、传递、对称&lt;/li&gt;
  &lt;li&gt;引用等价性 referential equality —— &lt;code class=&quot;highlighter-rouge&quot;&gt;==&lt;/code&gt;
    &lt;ul&gt;
      &lt;li&gt;判断是否指向同一块内存地址&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;对称等价性 object equality —— &lt;code class=&quot;highlighter-rouge&quot;&gt;equals()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;instanceof&lt;/code&gt; is dynamic type checking, not the static type checking. It should be disallowed anywhere except for implementing equals. (&lt;code class=&quot;highlighter-rouge&quot;&gt;getClass()&lt;/code&gt; is also disallowed.)&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a.equals(b)&lt;/code&gt; —&amp;gt; &lt;code class=&quot;highlighter-rouge&quot;&gt;a.hashcode() == b.hashcode()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;a.hashcode() == b.hashcode()&lt;/code&gt; –\–&amp;gt;  &lt;code class=&quot;highlighter-rouge&quot;&gt;a.equals(b)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;x.equals(null)&lt;/code&gt; must return false&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;int&lt;/code&gt; 放入&lt;code class=&quot;highlighter-rouge&quot;&gt;Map&amp;lt;String, Integer&amp;gt;&lt;/code&gt;后自动变为&lt;code class=&quot;highlighter-rouge&quot;&gt;Integer&lt;/code&gt;类型，取出后应该用&lt;code class=&quot;highlighter-rouge&quot;&gt;equals()&lt;/code&gt;方法比较&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;clone&quot;&gt;clone&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;调用&lt;code class=&quot;highlighter-rouge&quot;&gt;clone()&lt;/code&gt;返回的对象是一个独立的副本，两个对象地址不同，属性相同。&lt;/li&gt;
  &lt;li&gt;若类型&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;中有mutable成员变量&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;，那么对&lt;code class=&quot;highlighter-rouge&quot;&gt;A&lt;/code&gt;的clone对象进行修改时将修改原有的&lt;code class=&quot;highlighter-rouge&quot;&gt;B&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;如果实现完整的深拷贝，需要被复制对象的继承链、引用链上的每一个对象都实现克隆机制。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;immutable-type&quot;&gt;Immutable type&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;AF(a) = AF(b)&lt;/li&gt;
  &lt;li&gt;必须同时重写&lt;code class=&quot;highlighter-rouge&quot;&gt;equals()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;hashcode()&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;对于immutable类型的对象来说，因为没有mutable方法，所以观察等价性与行为等价性一致。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mutable-type&quot;&gt;Mutable type&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;观察等价性 observational equality&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;在不改变状态的情况下观察两个mutable对象是否看起来一致&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;行为等价性 behavioral equality
    &lt;ul&gt;
      &lt;li&gt;调用对象的任何方法都展示出一致的结果&lt;/li&gt;
      &lt;li&gt;mutable内容改变后&lt;code class=&quot;highlighter-rouge&quot;&gt;hashcode&lt;/code&gt;随之改变
        &lt;ul&gt;
          &lt;li&gt;如果某个mutable的对象包含在集合类中，当其发生改变后，集合类的行为不确定😢&lt;/li&gt;
          &lt;li&gt;只影响&lt;code class=&quot;highlighter-rouge&quot;&gt;HashSet&lt;/code&gt;，不影响&lt;code class=&quot;highlighter-rouge&quot;&gt;TreeSet&lt;/code&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections&lt;/code&gt; 使用&lt;strong&gt;观察等价性&lt;/strong&gt; —— &lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt; 的&lt;code class=&quot;highlighter-rouge&quot;&gt;equals()&lt;/code&gt;方法被重写
    &lt;ul&gt;
      &lt;li&gt;List 首先判断Null 然后判断size 最后依次比较每个内容的&lt;code class=&quot;highlighter-rouge&quot;&gt;equals()&lt;/code&gt;方法比较&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;其他可变类型 (如&lt;code class=&quot;highlighter-rouge&quot;&gt;StringBuilder&lt;/code&gt;) 使用&lt;strong&gt;行为等价性&lt;/strong&gt; —— &lt;code class=&quot;highlighter-rouge&quot;&gt;StringBuilder&lt;/code&gt; 的 &lt;code class=&quot;highlighter-rouge&quot;&gt;equals()&lt;/code&gt;方法继承自&lt;code class=&quot;highlighter-rouge&quot;&gt;Object&lt;/code&gt;类&lt;/li&gt;
  &lt;li&gt;大多情况下无需重写 直接继承&lt;/li&gt;
&lt;/ul&gt;

</description>
        <pubDate>Mon, 01 Apr 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/Software-Construction-Summary-3.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/Software-Construction-Summary-3.html</guid>
        
        <category>CODE</category>
        
        <category>SOFTWARE-CONSTRUCTION</category>
        
        <category>JAVA</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>Software Construction Summary 2</title>
        <description>&lt;h2 id=&quot;test-first-programming&quot;&gt;Test-First Programming&lt;/h2&gt;
&lt;h3 id=&quot;testing-levels&quot;&gt;Testing levels&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Unit testing 单元测试
    &lt;ul&gt;
      &lt;li&gt;等价类划分 partitioning
 • 全覆盖 Full cartestian produck
 • 覆盖每个取值 Cover each part&lt;/li&gt;
      &lt;li&gt;边界值分析 BVA (binary value analysis)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Integration testing 集成测试&lt;/li&gt;
  &lt;li&gt;System testing 系统测试&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;设计spec —&amp;gt;设计test cases —&amp;gt; code&lt;/p&gt;
&lt;h3 id=&quot;code-coverage&quot;&gt;Code coverage&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Fuction coverage&lt;/li&gt;
  &lt;li&gt;Statement coverage&lt;/li&gt;
  &lt;li&gt;Branch coverage&lt;/li&gt;
  &lt;li&gt;Condition coverage&lt;/li&gt;
  &lt;li&gt;Path coverage&lt;/li&gt;
  &lt;li&gt;path &amp;gt; branch &amp;gt; statement&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;adt&quot;&gt;ADT&lt;/h2&gt;
&lt;h3 id=&quot;primitive-typesreference-types&quot;&gt;Primitive Types/Reference Types&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;primitive types
    &lt;ul&gt;
      &lt;li&gt;stack, exist only when in use&lt;/li&gt;
      &lt;li&gt;immutable&lt;/li&gt;
      &lt;li&gt;no ID, only value&lt;/li&gt;
      &lt;li&gt;dirt cheap&lt;/li&gt;
      &lt;li&gt;int, long, byte, short, char, float, double, boolean&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Object Reference Types
    &lt;ul&gt;
      &lt;li&gt;heap, garbage collected&lt;/li&gt;
      &lt;li&gt;some mutable, some not&lt;/li&gt;
      &lt;li&gt;ID + value&lt;/li&gt;
      &lt;li&gt;more costly&lt;/li&gt;
      &lt;li&gt;Classes, interfaces, arrays, enums, annotations&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;static-typesdynamic-types&quot;&gt;Static Types/Dynamic Types&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;static types
    &lt;ul&gt;
      &lt;li&gt;在编译阶段进行类型检查 – type&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;dynamic data types
    &lt;ul&gt;
      &lt;li&gt;在运行阶段进行类型检查 – value&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;immutablemutable&quot;&gt;Immutable/Mutable&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;immutability - final
    &lt;ul&gt;
      &lt;li&gt;references / value cannot be changed&lt;/li&gt;
      &lt;li&gt;final class cannot be inherited&lt;/li&gt;
      &lt;li&gt;final method cannot be overridden by subclasses&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;String —— immutable&lt;/li&gt;
  &lt;li&gt;StringBuilder —— mutable (never use Date)
    &lt;ul&gt;
      &lt;li&gt;防御式拷贝 defensive copy
        &lt;ul&gt;
          &lt;li&gt;避免指向同一内存地址 避免被修改的潜在风险&lt;/li&gt;
          &lt;li&gt;可能造成内存浪费&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Sat, 16 Mar 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/SoftwareConstructionSummary2.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/SoftwareConstructionSummary2.html</guid>
        
        <category>CODE</category>
        
        <category>ANDROID</category>
        
        <category>JAVA</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>Software Construction Summary 1</title>
        <description>&lt;h2 id=&quot;multi-dimensional-software-views&quot;&gt;Multi-dimensional software views&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;By phases: &lt;strong&gt;build-time&lt;/strong&gt; and &lt;strong&gt;run-time&lt;/strong&gt; views&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;By dynamics: &lt;strong&gt;moment&lt;/strong&gt; and &lt;strong&gt;period&lt;/strong&gt; views&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;By levels: &lt;strong&gt;code&lt;/strong&gt; and &lt;strong&gt;component&lt;/strong&gt; views&lt;/p&gt;
    &lt;ul&gt;
      &lt;li&gt;logically / physically&lt;/li&gt;
      &lt;li&gt;in-memory states / physical environment&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;build-time&quot;&gt;Build-time&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;idea—&amp;gt;requirement—&amp;gt;design—&amp;gt;code—&amp;gt;installable / executable package&lt;/li&gt;
  &lt;li&gt;moment
    &lt;ul&gt;
      &lt;li&gt;code
        &lt;ul&gt;
          &lt;li&gt;Build-time, moment, and code-level view&lt;/li&gt;
          &lt;li&gt;Lexical-oriented source code :e.g.,Lexical-based semi-structured source code&lt;/li&gt;
          &lt;li&gt;Syntax-oriented program structure: e.g., Abstract Syntax Tree (AST)&lt;/li&gt;
          &lt;li&gt;&lt;strong&gt;Semantics-oriented program structure: e.g., Class Diagram(UML)&lt;/strong&gt;&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;component
        &lt;ul&gt;
          &lt;li&gt;Build-time, period, and code-level view&lt;/li&gt;
          &lt;li&gt;file, package, library&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;period
    &lt;ul&gt;
      &lt;li&gt;code
        &lt;ul&gt;
          &lt;li&gt;code churn&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;component
        &lt;ul&gt;
          &lt;li&gt;SCI&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;run-time&quot;&gt;Run-time&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;High-level concepts
    &lt;ul&gt;
      &lt;li&gt;Executable programs&lt;/li&gt;
      &lt;li&gt;Libraries&lt;/li&gt;
      &lt;li&gt;Configuration and data files&lt;/li&gt;
      &lt;li&gt;Distributed program&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;moment
    &lt;ul&gt;
      &lt;li&gt;code
        &lt;ul&gt;
          &lt;li&gt;Snapshot diagram&lt;/li&gt;
          &lt;li&gt;Memory dump&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;component
        &lt;ul&gt;
          &lt;li&gt;Deployment diagram in URL&lt;/li&gt;
          &lt;li&gt;Dynamic linking&lt;/li&gt;
          &lt;li&gt;Framework/Net&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;period
    &lt;ul&gt;
      &lt;li&gt;code
        &lt;ul&gt;
          &lt;li&gt;&lt;strong&gt;Sequence diagram in UML&lt;/strong&gt;&lt;/li&gt;
          &lt;li&gt;Stack Trace&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;component
        &lt;ul&gt;
          &lt;li&gt;Event log&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;types-of-transformations&quot;&gt;Types of Transformations&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;NULL —&amp;gt; Code
    &lt;ul&gt;
      &lt;li&gt;– Programming / Coding&lt;/li&gt;
      &lt;li&gt;– Review, static analysis/checking&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Code —&amp;gt; Component
    &lt;ul&gt;
      &lt;li&gt;– Design (Chapter 3 ADT/OOP&lt;/li&gt;
      &lt;li&gt;– Build: compile, static link, package, install, etc&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Build-time —&amp;gt; Run-time
    &lt;ul&gt;
      &lt;li&gt;– Install / deploy&lt;/li&gt;
      &lt;li&gt;– Debug, unit/integration testing&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Moment —&amp;gt; Period
    &lt;ul&gt;
      &lt;li&gt;– Refactoring&lt;/li&gt;
      &lt;li&gt;– Version control&lt;/li&gt;
      &lt;li&gt;– Loading, dynamic linking, interpreting,execution&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;quality-objectives&quot;&gt;Quality Objectives&lt;/h2&gt;

&lt;h3 id=&quot;external-quality-factors&quot;&gt;External quality factors&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Correctness&lt;/strong&gt;
    &lt;ul&gt;
      &lt;li&gt;Conditional&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Robustness&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Extendibility&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Reusability&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Compatibility&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;Efficiency&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Portability&lt;/li&gt;
  &lt;li&gt;Ease of use&lt;/li&gt;
  &lt;li&gt;Functionality&lt;/li&gt;
  &lt;li&gt;Timeliness&lt;/li&gt;
  &lt;li&gt;Other qualities
    &lt;ul&gt;
      &lt;li&gt;Verifiability&lt;/li&gt;
      &lt;li&gt;Integrity&lt;/li&gt;
      &lt;li&gt;Repairability&lt;/li&gt;
      &lt;li&gt;Economy&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;external-quality-factors-1&quot;&gt;External quality factors&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;LoC&lt;/li&gt;
  &lt;li&gt;Complexity&lt;/li&gt;
  &lt;li&gt;Easy to understand&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;software-lifecycle-and-configuration-management&quot;&gt;Software Lifecycle and Configuration Management&lt;/h2&gt;

&lt;h3 id=&quot;scm&quot;&gt;SCM&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;SCI
    &lt;ul&gt;
      &lt;li&gt;Software Configuration Item (e.g., file)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;baseline
    &lt;ul&gt;
      &lt;li&gt;release&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;CMDB
    &lt;ul&gt;
      &lt;li&gt;.git&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;version-control-system-vcs&quot;&gt;Version Control System (VCS)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Local VCS&lt;/li&gt;
  &lt;li&gt;Centralized VCS&lt;/li&gt;
  &lt;li&gt;Distributed VCS&lt;/li&gt;
  &lt;li&gt;objectgraph
    &lt;ul&gt;
      &lt;li&gt;Commits: nodes in Object Graph&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;software-development-lifecyclesdlc&quot;&gt;Software Development Lifecycle(SDLC)&lt;/h2&gt;
&lt;ul&gt;
  &lt;li&gt;Waterfall (Linear)&lt;/li&gt;
  &lt;li&gt;Incremental (Linear)&lt;/li&gt;
  &lt;li&gt;Prototyping (Iterative)&lt;/li&gt;
  &lt;li&gt;V-Model (for verification and validation)&lt;/li&gt;
  &lt;li&gt;Sprial (Iterative)&lt;/li&gt;
  &lt;li&gt;Agile (Incremental+Iterative)&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Thu, 14 Mar 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/Sofrware-Construction-Summary1.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/Sofrware-Construction-Summary1.html</guid>
        
        <category>SOFTWARE-CONSTRUCTION</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>Lab1 Problem Solution</title>
        <description>&lt;h2 id=&quot;junit测试private方法&quot;&gt;JUnit测试private方法&lt;/h2&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;FriendshipGraph&lt;/code&gt;类中存在以下函数：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private void addEdge(Person person1, Person person2);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;由于&lt;code class=&quot;highlighter-rouge&quot;&gt;addEdge(Person, Person)&lt;/code&gt;权限为&lt;code class=&quot;highlighter-rouge&quot;&gt;private&lt;/code&gt;，在测试类中试图调用会出现如下报错：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;The method addEdge(Person, Person) from the type FriendshipGraph is not visible&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;使用Java语言中反射的语言特性：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Method addEdge = graph.getClass().getDeclaredMethod(&quot;addEdge&quot;, Person.class, Person.class);
addEdge.setAccessible(true);
Person p1 = new Person(&quot;Test1&quot;);
addEdge.invoke(graph, p1, p1);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;遍历map的方法&quot;&gt;遍历Map的方法&lt;/h2&gt;
&lt;h3 id=&quot;mapentry&quot;&gt;Map.Entry&lt;/h3&gt;
&lt;p&gt;可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Map.Entry&lt;/code&gt;是Map声明的一个内部接口，此接口为泛型，定义为Entry&amp;lt;K,V&amp;gt;。它表示Map中的一个实体（一个key-value对）。接口中有getKey(),getValue()方法。使用这种方法进行遍历效率高。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;for (Map.Entry&amp;lt;String,Set&amp;lt;String&amp;gt;&amp;gt; entry:followsGraph.entrySet()) {
	for (String string : entry.getValue()) {
    // TODO:
	}
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;lambda&quot;&gt;Lambda&lt;/h3&gt;
&lt;p&gt;java8提供了Lambda表达式支持，语法看起来更简洁，可以同时拿到key和value，性能低于entrySet。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void testLambda() {
  map.forEach((key, value) -&amp;gt; {
    // TODO:
  });
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;keysetvalues&quot;&gt;keySet/values&lt;/h3&gt;
&lt;p&gt;如果只需要map的key或者value，用map的keySet或values方法是最方便的&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void testKeySet() {
    for (Integer key : map.keySet()) {
      System.out.println(key);
    }
  }
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void testValues() {
  for (Integer value : map.values()) {
    System.out.println(value);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;iterator&quot;&gt;Iterator&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public void testIterator() {
  Iterator&amp;lt;Map.Entry&amp;lt;Integer, Integer&amp;gt;&amp;gt; iterator = map.entrySet().iterator();
  while (iterator.hasNext()) {
    Map.Entry&amp;lt;Integer, Integer&amp;gt; entry = iterator.next();
    // TODO:
    // iterator.remove();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;在用&lt;code class=&quot;highlighter-rouge&quot;&gt;foreach&lt;/code&gt;遍历&lt;code class=&quot;highlighter-rouge&quot;&gt;map&lt;/code&gt;时，如果改变其大小会报错，但如果只是删除元素，可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;的&lt;code class=&quot;highlighter-rouge&quot;&gt;remove&lt;/code&gt;方法删除元素.&lt;/p&gt;
&lt;h2 id=&quot;javautilconcurrentmodificationexception&quot;&gt;java.util.ConcurrentModificationException&lt;/h2&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;是工作在一个独立的线程中，并且拥有一个&lt;code class=&quot;highlighter-rouge&quot;&gt;mutex&lt;/code&gt;锁，就是说&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;在工作的时候，是不允许被迭代的对象被改变的。&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;被创建的时候，建立了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;内存索引表&lt;/code&gt;（单链表），这个索引表指向&lt;code class=&quot;highlighter-rouge&quot;&gt;原来的对象&lt;/code&gt;，当原来的对象数量改变的时候，这个索引表的内容没有同步改变，所以当索引指针往下移动的时候，便找不到要迭代的对象，于是产生错误。&lt;code class=&quot;highlighter-rouge&quot;&gt;List&lt;/code&gt;、&lt;code class=&quot;highlighter-rouge&quot;&gt;Set&lt;/code&gt;等是动态的，可变对象数量的数据结构，但是&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;则是&lt;code class=&quot;highlighter-rouge&quot;&gt;单向不可变&lt;/code&gt;，只能&lt;code class=&quot;highlighter-rouge&quot;&gt;顺序读取&lt;/code&gt;，不能逆序操作的数据结构，当&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;指向的原始数据发生变化时，&lt;code class=&quot;highlighter-rouge&quot;&gt;Iterator&lt;/code&gt;自己就迷失了方向。&lt;/p&gt;
&lt;h2 id=&quot;arraylist的排序&quot;&gt;ArrayList的排序&lt;/h2&gt;
&lt;p&gt;对&lt;code class=&quot;highlighter-rouge&quot;&gt;list&lt;/code&gt;自定义排序可以使用到了&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.sort&lt;/code&gt;函数&lt;code class=&quot;highlighter-rouge&quot;&gt;Collections.sort(List, Comparator)&lt;/code&gt;
在这里自定义&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparator&lt;/code&gt;后对其&lt;code class=&quot;highlighter-rouge&quot;&gt;compare&lt;/code&gt;函数进行重写&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;List&amp;lt;Map.Entry&amp;lt;String,Integer&amp;gt;&amp;gt; list = new ArrayList&amp;lt;Map.Entry&amp;lt;String, Integer&amp;gt;&amp;gt;(followers.entrySet());
Collections.sort(list,new Comparator&amp;lt;Map.Entry&amp;lt;String, Integer&amp;gt;&amp;gt;(){
	@Override
	public int compare(Entry&amp;lt;String, Integer&amp;gt; o1, Entry&amp;lt;String, Integer&amp;gt; o2) {
		if (o1.getValue() &amp;gt; o2.getValue()) return -1;
		else return 1;
	}
});
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 07 Mar 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/Bug1.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/Bug1.html</guid>
        
        <category>SOFTWARE-CONSTRUCTION</category>
        
        <category>JAVA</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>Caffe</title>
        <description>&lt;h2 id=&quot;homebrew--macos-缺失的软件包的管理器&quot;&gt;Homebrew —— macOS 缺失的软件包的管理器&lt;/h2&gt;

&lt;h3 id=&quot;安装homebrew&quot;&gt;安装Homebrew&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;/usr/bin/ruby -e &quot;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install)&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;使用 Homebrew 安装 Apple 没有预装但你需要的东西。Homebrew 会将软件包安装到独立目录，并将其文件软链接至 /usr/local。&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;$ brew install wget
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;添加依赖&quot;&gt;添加依赖&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;brew install -vd snappy leveldb gflags glog szip lmdb
brew tap homebrew/science
brew install hdf5 opencv
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;brew-edit-opencv-修改以下内容&quot;&gt;brew edit opencv 修改以下内容&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-DPYTHON_LIBRARY=#{py_prefix}/lib/libpython2.7.dylib
-DPYTHON_INCLUDE_DIR=#{py_prefix}/include/python2.7

# with Python pycaffe needs dependencies built from source
brew install --build-from-source --with-python -vd protobuf
brew install --build-from-source -vd boost boost-python
# without Python the usual installation suffices
brew install protobuf boost
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;编译&quot;&gt;编译&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;mkdir build
cd build
cmake ..
make all
make install
make runtest
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;solutions&quot;&gt;Solutions&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python/caffe/_caffe.cpp:1:10: fatal error: 'Python.h' file not found

export CPLUS_INCLUDE_PATH=&quot;$CPLUS_INCLUDE_PATH:/anaconda3/pkgs/python-3.6.5-hc167b69_1/include/python3.6m&quot;

python/caffe/_caffe.cpp:10:10: fatal error: 'numpy/arrayobject.h' file not found

export CPLUS_INCLUDE_PATH=&quot;$CPLUS_INCLUDE_PATH:/anaconda3/lib/python3.6/site-packages/numpy/core/include&quot;
     
conda create -n py2 python=2.7
activate/deactivate py2
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;修改环境变量&quot;&gt;修改环境变量&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; 打开配置文件
 $ open ~/.bash_profile

 写入python的外部环境变量
 export PATH=${PATH}:/Library/Frameworks/Python.framework/Versions/3.6/bin
 
重命名python
alias python=&quot;/Library/Frameworks/Python.framework/Versions/3.6/bin/python3.6&quot;
（这步很重要，直接关系到默认启动的python版本是否修改）

$ source ~/.bash_profile

查看是否修改成功
$ python

export PYTHONPATH=&amp;lt;path_to_caffe&amp;gt;/caffe-1.0/python:$PYTHONPATH

verify build
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;检验安装是否成功&quot;&gt;检验安装是否成功&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;python -c 'import caffe'
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;install--launch-digits&quot;&gt;install &amp;amp; launch DIGITS&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;添加环境变量
export DIGITS_ROOT=&quot;~/Documents/DIGITS&quot;
export CAFFE_ROOT='~/Documents/caffe'

git clone https://github.com/NVIDIA/caffe.git $CAFFE_ROOT
cd $DIGITS_ROOT
sudo pip install -r $CAFFE_ROOT/python/requirements.txt
open ./digits-devserver 修改最后一行 python 为 python2.7

运行
./digits-devserver

http://localhost:5000
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Caught PicklingError while saving job 20171212-140813-6b62: Can't pickle &amp;lt;class 'caffe.proto.caffe_pb2.NetParameter'&amp;gt;: it's not the same object as caffe.proto.caffe_pb2.NetParameter
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;this bug has a long story https://github.com/NVIDIA/DIGITS/issues/306&lt;/p&gt;

&lt;p&gt;Replace all the &lt;code class=&quot;highlighter-rouge&quot;&gt;import caffe_pb2&lt;/code&gt; with &lt;code class=&quot;highlighter-rouge&quot;&gt;import caffe.proto.caffe_pb2 as caffe_pb2&lt;/code&gt;.&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Feb 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/Caffe.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/Caffe.html</guid>
        
        <category>CAFFE</category>
        
        <category>INSTALL</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>Raspberry Pi</title>
        <description>&lt;h2 id=&quot;wifi&quot;&gt;WIFI&lt;/h2&gt;
&lt;p&gt;在根目录下添加&lt;code class=&quot;highlighter-rouge&quot;&gt;wpa_supplicant.conf&lt;/code&gt;, &lt;code class=&quot;highlighter-rouge&quot;&gt;ssh&lt;/code&gt;两个文件，其中&lt;code class=&quot;highlighter-rouge&quot;&gt;ssh&lt;/code&gt;为空&lt;/p&gt;
&lt;h3 id=&quot;bootwpa_supplicantconf&quot;&gt;/boot/wpa_supplicant.conf&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;country=GB
ctrl_interface=DIR=/var/run/wpa_supplicant GROUP=netdev
update_config=1

network={
    ssid=&quot;WIFI名&quot;
    psk=&quot;WIFI密码&quot;
    key_mgmt=WPA-PSK
    priority=1
}

network={
    ssid=&quot;WIFI名&quot;
    psk=&quot;WIFI密码&quot;
    key_mgmt=WPA-PSK
    priority=2
} --- ## Bluetooth

安装支持包
sudo apt-get install pi-bluetooth
sudo apt-get install bluetooth bluez blueman

添加pi用户到蓝牙组 
sudo usermod -G bluetooth -a pi

启动/增加SPP
sudo nano /etc/systemd/system/dbus-org.bluez.service 
  
修改内容如下:
ExecStart=/usr/lib/bluetooth/bluetoothd -C
ExecStartPost=/usr/bin/sdptool add SP

连接蓝牙
sudo rfcomm watch hci0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;gps--l80-m39&quot;&gt;GPS  L80-M39&lt;/h2&gt;

&lt;h3 id=&quot;1-安装gps模块需要的包&quot;&gt;1. 安装GPS模块需要的包&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo apt-get update &amp;amp;&amp;amp; sudo apt-get -y install gpsd gpsd-clients python-gps
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;2-重启树莓派重新配置gps服务&quot;&gt;2. 重启树莓派，重新配置GPS服务&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo dpkg-reconfigure gpsd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;3-开启gps模块服务&quot;&gt;3. 开启GPS模块服务:&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo gpsd /dev/ttyUSB0 -F /var/run/gpsd.sock
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;4-停止gps服务&quot;&gt;4. 停止GPS服务:&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo killall gpsd
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;5-你也可以使用systemctl命令管理gps服务但在那之前需要修改文件etcdefaultgpsd&quot;&gt;5. 你也可以使用&lt;code class=&quot;highlighter-rouge&quot;&gt;systemctl&lt;/code&gt;命令管理GPS服务，但在那之前需要修改文件&lt;code class=&quot;highlighter-rouge&quot;&gt;/etc/default/gpsd&lt;/code&gt;&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;START_DAEMON=&quot;true&quot;
USBAUTO=&quot;true&quot;
DEVICES=&quot;/dev/ttyUSB0&quot;
GPSD_OPTIONS=&quot;-F /var/run/gpsd.socket&quot;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;开始服务&quot;&gt;开始服务:&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl enable gpsd.sock sudo systemctl start gpsd.sock
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;停止服务&quot;&gt;停止服务:&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo systemctl stop gpsd.sock sudo systemctl disable gpsd.sock
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;获取模块信息&quot;&gt;获取模块信息&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;sudo cgps -s
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;如果不能正常获得信息使用以下命令检查串口工作是否正常&quot;&gt;如果不能正常获得信息，使用以下命令检查串口工作是否正常&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;cat/dev/ttyUSB0 
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;无定位情况下显示如下&quot;&gt;无定位情况下显示如下:&lt;/h3&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;pi@raspberrypi ~ $ sudo cat /dev/ttyUSB0
$GPRMC,144034.00,V,,,,,,,090315,,,N*75
$GPVTG,,,,,,,,,N*30
$GPGGA,144034.00,,,,,0,00,99.99,,,,,,*60
$GPGSA,A,1,,,,,,,,,,,,,99.99,99.99,99.99*30
$GPGSV,1,1,01,15,,,25*7B
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;NO FIX&lt;/code&gt; 即未定位，将模块移动到室外空旷处将获得定位信息。&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;ssh&quot;&gt;SSH&lt;/h2&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;使用ssh登陆pi 默认用户名pi 密码raspberry
ssh pi@192.168.2.104

新建vnc服务 VNCViewer中ip:port登陆 默认port为0
vncservice

停止对应的vnc服务进程
vncservice -kill :1
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;使用python解析串口数据并发送至蓝牙&quot;&gt;使用python解析串口数据并发送至蓝牙&lt;/h2&gt;

&lt;h3 id=&quot;准备&quot;&gt;准备&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;安装python库
sudo aptitude install python-dev
sudo apt-get install python-serial
python -m pip install pynmea2

赋予串口读写权限
sudo chmod 777 /dev/rfcomm0
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;python代码&quot;&gt;python代码：&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;import serial
import pynmea2
import time
ser1 = serial.Serial(&quot;/dev/ttyUSB0&quot;,9600)
ser2 = serial.Serial('/dev/rfcomm0',9600,parity=serial.PARITY_NONE)
if ser2.isOpen == False:
    ser2.open()
ser2.write(&quot;serial turn on\n&quot;)

try:
    while True:
        line = ser1.readline()
        if line.startswith('$GPRMC'):
            rmc = pynmea2.parse(line)
            ser2.write(&quot;Latitude: &quot; +rmc.lat +&quot;Longitude: &quot;+rmc.lon+&quot;\n&quot;)
        
except KeyboardInterrupt:
        ser2.close()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

</description>
        <pubDate>Wed, 23 Jan 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/Raspberry-Pi.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/Raspberry-Pi.html</guid>
        
        <category>RaspberryPi</category>
        
        <category>INSTALL</category>
        
        
        <category>coding</category>
        
      </item>
    
  </channel>
</rss>
