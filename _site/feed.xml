<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Aether's Blog</title>
    <description>Keep calm and carry on # this means to ignore newlines until &quot;baseurl:&quot;
</description>
    <link>http://localhost:4000/</link>
    <atom:link href="http://localhost:4000/feed.xml" rel="self" type="application/rss+xml"/>
    <pubDate>Mon, 13 Jan 2020 12:57:15 +0800</pubDate>
    <lastBuildDate>Mon, 13 Jan 2020 12:57:15 +0800</lastBuildDate>
    <generator>Jekyll v4.0.0</generator>
    
      <item>
        <title>🍳主成分分析 PCA</title>
        <description>&lt;h1 id=&quot;-降维&quot;&gt;🍳 降维&lt;/h1&gt;

&lt;h2 id=&quot;主成分分析-principal-component-analysis--pca&quot;&gt;主成分分析 &lt;em&gt;Principal Component Analysis&lt;/em&gt; —— PCA&lt;/h2&gt;

&lt;p&gt;PCA的本质是将$n$维数据投影到$k$维空间中。若存在一个超平面，可以对正交属性空间中的样本点进行恰当的表达，那么这个超平面具有最近重构性和最大可分性。&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;最近重构性&lt;/strong&gt;：样本点到这个超平面的距离都足够近&lt;/li&gt;
  &lt;li&gt;&lt;strong&gt;最大可分性&lt;/strong&gt;：样本点在这个超平面上的投影尽可能分开&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;从最大可分性证明&quot;&gt;从最大可分性证明&lt;/h2&gt;

&lt;p&gt;​	样本点$\boldsymbol x_i $在新空间中超平面上的投影是$\bf W^T \boldsymbol x_i $，若使所有样本点的投影尽可能分开，则应该使投影后样本点的方差最大化。投影后样本点的方差为$\sum_i \bf W^T \boldsymbol x_i \boldsymbol x_i^T\bf W$，则优化目标和限制条件如下：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\max_{\boldsymbol W} \ \rm{tr}( \bf W^T\bf X \bf X^T\bf W )&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\rm {s.t.}  \bf W^T \bf W = \bf I&lt;/script&gt;

&lt;p&gt;使用拉格朗日乘子法：&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;\bf X \bf X^T\bf W = \lambda \bf W&lt;/script&gt;
对协方差矩阵$\boldsymbol X \boldsymbol X^T$进行特征值分解，并将求的的特征值进行排序，取前$k$个最大的特征值对应的特征向量构成投影矩阵$\bf W = {\boldsymbol w_1,\boldsymbol w_2, \dots,\boldsymbol w_k}$&lt;/p&gt;

&lt;p&gt;注：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
{\bf X} =\left[    \begin{matrix}        {\boldsymbol x}^{(1)} - \overline {\bf X}\\        {\boldsymbol x}^{(2)}- \overline {\bf X} \\        \vdots \\        {\boldsymbol x}^{(m)} - \overline {\bf X}   \end{matrix}    \right] =    \left[        \begin{matrix}            x^{(1)}_{1}- \overline {x}_1 &amp; x^{(1)}_{2}- \overline {x}_2   &amp; \cdots &amp; x^{(1)}_{n}- \overline {x}_n   \\            x^{(2)}_{1}- \overline {x}_1 &amp; x^{(2)}_{2} - \overline {x}_2  &amp; \cdots &amp; x^{(2)}_{n}- \overline {x}_n   \\            \vdots &amp; \vdots &amp; \ddots &amp; \vdots \\            x^{(m)}_{1}- \overline {x}_1 &amp; x^{(m)}_{2}- \overline {x}_2 &amp; \cdots &amp; x^{(m)}_{n}- \overline {x}_n        \end{matrix}        \right] %]]&gt;&lt;/script&gt;

&lt;p&gt;故$\boldsymbol X \boldsymbol X^T$为协方差矩阵&lt;/p&gt;

&lt;h2 id=&quot;算法流程&quot;&gt;算法流程&lt;/h2&gt;

&lt;p&gt;给定数据集$D = { \boldsymbol x_1, \boldsymbol x_2, \dots, \boldsymbol x_m}$，对样本进行中心化，即&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\boldsymbol x_i \leftarrow \boldsymbol x_i - \boldsymbol \mu&lt;/script&gt;

&lt;p&gt;其中${\boldsymbol \mu} = \frac{1}{m}\sum\limits_{j = 1}^m{\boldsymbol x}_j$，为数据集的$D$的均值向量。这个步骤相当于平移坐标轴到所有数据点的平均中点位置。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/PCA.png&quot; alt=&quot;6&quot; style=&quot;zoom:50%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;​	当数据受到噪声影响时，最小的特征值对应的特征向量往往与噪声有关，将它们舍弃在一定程度上起到去噪的效果。&lt;/p&gt;

&lt;h2 id=&quot;信噪比-snr--signal-to-noise-ratio&quot;&gt;信噪比 SNR —— &lt;em&gt;Signal to Noise Ratio&lt;/em&gt;&lt;/h2&gt;

&lt;p&gt;信噪比公式如下：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;{SNR} = 10·\log_{10}\left[\frac{\sum\limits_{x=1}^{N_x}\sum\limits_{y=1}^{N_y}\left[f(x,y)\right]^2}{\sum\limits_{x=1}^{N_x}\sum\limits_{y=1}^{N_y}\left[f(x,y)-\hat f(x,y)\right]^2}\right]&lt;/script&gt;

&lt;p&gt;设样本个数为$m$，维数为$n$
&lt;script type=&quot;math/tex&quot;&gt;\hat y = X^T\boldsymbol \theta_0 + \sum_{j=1}^Mc_j·\max
\{0,X^T\boldsymbol \theta_j\}&lt;/script&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\boldsymbol \theta = \left[\begin{matrix}     b  \\     \theta_1 \\    \theta_2\\  \vdots\\     \theta_n\end{matrix}\right],
\boldsymbol x = \left[\begin{matrix}   1\\   x_1  \\     x_2 \\       \vdots\\     x_n\end{matrix}\right] \rightarrow f(x)= \boldsymbol \theta^T \boldsymbol x&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
{\boldsymbol \theta} =\left[    
\begin{matrix}        
{\boldsymbol \theta}^{(1)}\\        
{\boldsymbol \theta}^{(2)} \\        
\vdots \\        
{\boldsymbol \theta}^{(M)} 
\end{matrix}    \right] =    
\left[        
\begin{matrix}            
\theta^{(1)}_{1} &amp; \theta^{(1)}_{2}  &amp;\dots&amp; \theta^{(1)}_{n}   \\      

\theta^{(2)}_{1} &amp; \theta^{(2)}_{2}  &amp;\dots&amp; \theta^{(2)}_{n}   \\   
\vdots&amp;\vdots&amp;\ddots&amp;\vdots&amp;\\

\theta^{(M)}_{1} &amp; \theta^{(M)}_{2}  &amp;\dots&amp; \theta^{(M)}_{n}   \\   

\end{matrix}        
\right] 

\boldsymbol X = 
\left[
\begin{matrix}   
1&amp;1&amp;\dots&amp;1\\  
x^{(1)}_1&amp;x^{(2)}_1&amp;\dots&amp;x^{(m)}_1  \\     
x^{(1)}_2&amp;x^{(2)}_2&amp;\dots&amp;x^{(m)}_2 \\       
\vdots\\     
x^{(1)}_n&amp;x^{(2)}_n&amp;\dots&amp;x^{(m)}_n
\end{matrix}

\right]

\\

\boldsymbol \theta \boldsymbol X = 
\left[\begin{matrix}   
 
\boldsymbol \theta^{(1)}\boldsymbol x^{(1)} &amp;
\boldsymbol \theta^{(1)}\boldsymbol x^{(2)} &amp;
\dots &amp;
\boldsymbol \theta^{(1)}\boldsymbol x^{(m)}\\ 

\boldsymbol \theta^{(2)}\boldsymbol x^{(1)} &amp;
\boldsymbol \theta^{(2)}\boldsymbol x^{(2)} &amp;
\dots &amp;
\boldsymbol \theta^{(2)}\boldsymbol x^{(m)}\\    

\vdots&amp;\vdots&amp;\ddots&amp;\vdots\\     
 
\boldsymbol \theta^{(M)}\boldsymbol x^{(1)} &amp;
\boldsymbol \theta^{(M)}\boldsymbol x^{(2)} &amp;
\dots &amp;
\boldsymbol \theta^{(M)}\boldsymbol x^{(m)}\\   
\end{matrix}

\right]
\\
\boldsymbol \theta^{(j)} \boldsymbol x^{(k)} =  \sum  \boldsymbol \theta^{(j)}_i \boldsymbol x^{(k)}_i %]]&gt;&lt;/script&gt;

</description>
        <pubDate>Sun, 24 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/PCA.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/PCA.html</guid>
        
        <category>CODE</category>
        
        <category>MACHINELEARNING</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>🐣 SVM推导与总结</title>
        <description>&lt;h2 id=&quot;logistic代价函数推导svm&quot;&gt;Logistic代价函数推导SVM&lt;/h2&gt;

&lt;p&gt;0/1损失函数$l_{0/1}$非凸、非连续，数学性质差，故常用其他函数代替$l_{0/1}$&lt;/p&gt;

&lt;p&gt;三种常用的替代损失函数：
&lt;script type=&quot;math/tex&quot;&gt;l_{hinge}(z) = \max(0,1-z)&lt;/script&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;l_{exp}(z) = e^{-z}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;l_{log}(z) = log(1+e^{-z})&lt;/script&gt;

&lt;h3 id=&quot;logistic-regression&quot;&gt;Logistic Regression&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_\theta \frac{1}{m} \left[ \sum_{i=1}^m y^{(i)}\left[-\log(h_{\theta}(x^{(i)}))\right]+(1-y^{(i)})\left[-\log(1-h_{\theta}(x^{(i)}))\right]\right]+\frac{\lambda}{2m}\sum_{j=1}^n\theta_j^2&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_\theta  \left[ \sum_{i=1}^m 
y^{(i)}cost_1
+(1-y^{(i)})cost_0\right] 
+\frac{\lambda}{2}\sum_{j=1}^n\theta_j^2&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;A + \lambda B&lt;/script&gt;

&lt;h3 id=&quot;svm&quot;&gt;SVM&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;C A + B&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_\theta C  \sum_{i=1}^m\left[ y^{(i)}cost_1(\boldsymbol \theta^T\boldsymbol x^{(i)})+(1-y^{(i)})cost_0({\boldsymbol \theta}^T\boldsymbol x^{(i)})\right]+\frac{1}{2}\sum_{j=1}^n\theta_j^2&lt;/script&gt;

&lt;p&gt;其中SVM中的代价函数$cost$采用$hinge$损失
&lt;script type=&quot;math/tex&quot;&gt;l_{hinge}(z) = \max(0,1-z)&lt;/script&gt;
如下所示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../img/svm_cost.png&quot; alt=&quot;5&quot; style=&quot;zoom:70%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;可以直观地发现当$y=1$时，我们希望$\boldsymbol \theta^T\boldsymbol x \gg 1$，这样使$cost_1$最小；当$y=0$时，我们希望$\boldsymbol \theta^T\boldsymbol x \ll -1$，这样使$cost_0$最小。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;margin&quot;&gt;Margin&lt;/h2&gt;

&lt;p&gt;设划分超平面的方程为
&lt;script type=&quot;math/tex&quot;&gt;\boldsymbol w^T\boldsymbol x +b =0&lt;/script&gt;&lt;/p&gt;

&lt;p&gt;样本中任意点到该超平面的距离为
&lt;script type=&quot;math/tex&quot;&gt;d = \frac{\boldsymbol w^T x +b}{||\boldsymbol w||}&lt;/script&gt;
对于$y=1$，$y=-1$两类样本点，任意点到超平面的距离应大于$d$
&lt;script type=&quot;math/tex&quot;&gt;\frac{\boldsymbol w^T  x^{(i)} +b}{||\boldsymbol w||} \geq d, \ \forall y^{(i)} = 1\\
\frac{\boldsymbol w^T  x^{(i)} +b}{||\boldsymbol w||} \leq -d, \ \forall y^{(i)} = -1
\\ \Downarrow \\
\frac{\boldsymbol w^T  x^{(i)} +b}{||\boldsymbol w||d} \geq 1, \ \forall y^{(i)} = 1\\
\frac{\boldsymbol w^T  x^{(i)} +b}{||\boldsymbol w||d} \leq -1, \ \forall y^{(i)} = -1
\\ \Downarrow \\
\boldsymbol w_d^T  x^{(i)} +b_d \geq 1, \ \forall y^{(i)} = 1\\
\boldsymbol w_d^T  x^{(i)} +b_d \leq -1, \ \forall y^{(i)} = -1
\\ \Downarrow \\
y^{(i)}(\boldsymbol w^T  x^{(i)} +b) \geq 1&lt;/script&gt;
&lt;img src=&quot;../img/svm_margin.png&quot; style=&quot;zoom:30%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;对于任意支撑向量，优化目标为最大化点到超平面的距离：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\max \frac{|\boldsymbol w^T x +b|}{||\boldsymbol w||} \Rightarrow \max \frac{1}{||\boldsymbol w||}  \Rightarrow \min \frac{1}{2}||w||^2&lt;/script&gt;

&lt;p&gt;则SVM的优化目标为：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{\boldsymbol w,b} \frac{1}{2}||\boldsymbol w||^2 \\
{\rm{s.t.}} \ \ y^{(i)}(\boldsymbol w^T \boldsymbol x^{(i)}+b)\geq 1, \ i = 1,2,\dots,m.&lt;/script&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;软间隔-soft-margin-svm&quot;&gt;软间隔 Soft Margin SVM&lt;/h2&gt;

&lt;p&gt;非线性可分情况，允许误差$\xi_i$&lt;/p&gt;

&lt;p&gt;L1正则&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{\boldsymbol w,b} \frac{1}{2}||\boldsymbol w||^2 + C\sum_{i=1}^m \xi_i\\
{\rm{s.t.}} \ \ y^{(i)}(\boldsymbol w^T \boldsymbol x^{(i)}+b)\geq 1 - \xi_i \\\ i = 1,2,\dots,m,\ \xi_i\geq0&lt;/script&gt;

&lt;p&gt;L2正则&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{\boldsymbol w,b} \frac{1}{2}||\boldsymbol w||^2 + C\sum_{i=1}^m \xi_i^2\\
{\rm{s.t.}} \ \ y^{(i)}(\boldsymbol w^T \boldsymbol x^{(i)}+b)\geq 1 - \xi_i \\\ i = 1,2,\dots,m,\ \xi_i\geq0&lt;/script&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;拉格朗日对偶性-lagrangian-duality&quot;&gt;拉格朗日对偶性 Lagrangian Duality&lt;/h2&gt;

&lt;p&gt;​	在约束最优化问题中，常常利用拉格朗日对偶性将原始问题转为对偶问题，通过解决对偶问题而得到原始问题的解。当满足一定条件时，原始问题与对偶问题的解是完全等价的。&lt;/p&gt;

&lt;p&gt;原始目标：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{\boldsymbol w,b} \frac{1}{2}||\boldsymbol w||^2&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;{\rm{s.t.}} \ \ y^{(i)}(\boldsymbol w^T \boldsymbol x^{(i)}+b)\geq 1, \ i = 1,2,\dots,m.&lt;/script&gt;

&lt;p&gt;使用拉格朗日乘法构造拉格朗日函数转化为无约束优化问题，其中拉格朗日乘子$\alpha_i\geq0$&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;L(\boldsymbol w,b, \boldsymbol \alpha) = \frac{1}{2}||\boldsymbol w||^2 + \sum_{i=1}^m\alpha_i(1-y^{(i)}(\boldsymbol w^T \boldsymbol x^{(i)}+b))&lt;/script&gt;

&lt;p&gt;将$L(\boldsymbol w,b, \boldsymbol \alpha) $看作是关于$\boldsymbol \alpha$的函数，求&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\max_{\boldsymbol \alpha} L(\boldsymbol w,b, \boldsymbol \alpha)&lt;/script&gt;

&lt;p&gt;当某个约束条件不满足时，如&lt;script type=&quot;math/tex&quot;&gt;% &lt;![CDATA[
y^{(i)}(\boldsymbol w^T \boldsymbol x^{(i)}+b)&lt; 1 %]]&gt;&lt;/script&gt;，那么显然有&lt;script type=&quot;math/tex&quot;&gt;\max\limits_{\boldsymbol \alpha} L(\boldsymbol w,b, \boldsymbol \alpha) = \infty&lt;/script&gt;（令&lt;script type=&quot;math/tex&quot;&gt;\alpha_i=\infty&lt;/script&gt;即可）而当所有约束条件都满足时，则最优值为&lt;script type=&quot;math/tex&quot;&gt;\frac{1}{2}\|\boldsymbol w\|^2&lt;/script&gt;，即最初要最小化的目标值。因此，在约束条件得到满足的情况下最小化&lt;script type=&quot;math/tex&quot;&gt;\frac{1}{2}\|\boldsymbol w\|^2&lt;/script&gt;，等同于求&lt;script type=&quot;math/tex&quot;&gt;\max\limits_{\boldsymbol \alpha} L(\boldsymbol w,b, \boldsymbol \alpha)&lt;/script&gt;的最小值。&lt;/p&gt;

&lt;p&gt;原始目标变为&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_{\boldsymbol w,b}\max_{\boldsymbol \alpha} L(\boldsymbol w,b, \boldsymbol \alpha)&lt;/script&gt;

&lt;p&gt;这个问题只有在满足约束条件下才有极小值，也就是说这个问题的极小值一定满足约束条件。&lt;/p&gt;

&lt;p&gt;令$\nabla_\boldsymbol w L = 0$，$\nabla_b L = 0$，得：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\boldsymbol w =\sum_{i=1}^m\alpha_iy_i\boldsymbol x_i&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\sum_{i=1}^m\alpha_iy_i = 0&lt;/script&gt;

&lt;p&gt;将其带入，则原始问题转化对偶问题：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\max_\boldsymbol \alpha\sum_{i=1}^m \alpha_i-\frac{1}{2}\sum_{i=1}^m\sum_{j=1}^m\alpha_i\alpha_jy_iy_j\boldsymbol x_i\boldsymbol x_j \\&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
{\rm{s.t.}} &amp;\  \sum_{i=1}^m\alpha_iy_i = 0,\\ 
&amp;\ \alpha_i\geq0, \ i = 1,2,\dots,m
\end{align} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;强对偶和弱对偶-strong-and-weak-duality&quot;&gt;强对偶和弱对偶 strong and weak duality&lt;/h3&gt;

&lt;p&gt;原始问题 Primal Problem&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;p^* = \min_w \max_{\alpha_i \geq 0} L(\boldsymbol w,b, \boldsymbol \alpha)&lt;/script&gt;
对偶问题 Dual Problem&lt;/p&gt;

&lt;p&gt;&lt;script type=&quot;math/tex&quot;&gt;d^* = \max_{\alpha_i \geq 0}\min_w  L(\boldsymbol w,b, \boldsymbol \alpha)&lt;/script&gt;
弱对偶性：
&lt;script type=&quot;math/tex&quot;&gt;d^* \leq p^*&lt;/script&gt;
强对偶性：
&lt;script type=&quot;math/tex&quot;&gt;d^* = p^*&lt;/script&gt;&lt;/p&gt;

&lt;h3 id=&quot;kkt-conditions&quot;&gt;KKT conditions&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;定常方程式 stationary equation&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\nabla_\boldsymbol w L = 0&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\nabla_b L = 0&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;原始可行性 primal feasibility&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;y^{(i)}(\boldsymbol w^T \boldsymbol x^{(i)}+b)\geq 1&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;对偶可行性 dual feasibility&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\alpha_i \geq 0&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;辅松弛 complementary slackness&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\alpha_i(y^{(i)}f(x^{(i)})-1)=0&lt;/script&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;核函数-kernel-trick&quot;&gt;核函数 Kernel Trick&lt;/h2&gt;

&lt;p&gt;在&lt;strong&gt;线性不可分&lt;/strong&gt;的情况下，支持向量机首先在低维空间中完成计算，然后通过核函数将输入空间映射到高维特征空间，最终在高维特征空间中构造出最优分离超平面，从而把平面上本身不好分的非线性数据分开——依靠升维使原本线性不可分的数据线性可分&lt;/p&gt;

&lt;p&gt;SVM优化问题经过对偶转化为了&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\max_\boldsymbol \alpha\sum_{i=1}^m \alpha_i-\frac{1}{2}\sum_{i=1}^m\sum_{j=1}^m\alpha_i\alpha_jy_iy_j\boldsymbol x_i\boldsymbol x_j&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
{\rm{s.t.}} &amp;\  \sum_{i=1}^m\alpha_iy_i = 0,\\ 
&amp;\ \alpha_i\geq0, \ i = 1,2,\dots,m
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;可以看到数据点仅出现为为内积$\boldsymbol x_i\boldsymbol x_j$&lt;/p&gt;

&lt;p&gt;只要能在特征空间中计算出内积，就不需要显式的映射。而且许多常见的几何操作（角度、距离）可以用内积表示。减少计算量和储存空间。&lt;/p&gt;

&lt;p&gt;定义核函数${\rm{K}} (\boldsymbol x_i,\boldsymbol x_j)=\boldsymbol x_i’·\boldsymbol x_j’=(\boldsymbol x_i·\boldsymbol x_j+1)^2$&lt;/p&gt;

&lt;p&gt;核函数本质是将数据添加多项式特征 $x \rightarrow x’$&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;x'= (x_n^2,\dots,x_1^2,\sqrt2 x_nx_{n-1},\dots,\sqrt2x_n\dots,\sqrt2 x_1,1)&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;核函数不是SVM专有&lt;/li&gt;
  &lt;li&gt;存在$\boldsymbol x_i·\boldsymbol x_j$即可应用核函数&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;核函数类型&quot;&gt;核函数类型&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;线性核函数 &lt;em&gt;Linear kernel&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;{\rm{K}} (\boldsymbol x_i,\boldsymbol x_j)=\boldsymbol x_i·\boldsymbol x_j&lt;/script&gt;

&lt;ol&gt;
  &lt;li&gt;多项式核函数 &lt;em&gt;Polynomial kernel&lt;/em&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;{\rm{K}} (\boldsymbol x_i,\boldsymbol x_j)=(\boldsymbol x_i·\boldsymbol x_j+1)^d&lt;/script&gt;

&lt;ol&gt;
  &lt;li&gt;高斯核函数 /  径向基函数 Radial Basis Function Kernel —— RBF&lt;/li&gt;
&lt;/ol&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;{\rm{K}} (\boldsymbol x_i,\boldsymbol x_j)=e^{-\gamma||\boldsymbol x_i-\boldsymbol x_j||^2}&lt;/script&gt;

&lt;p&gt;将每个样本点映射到无穷维的特征空间，每个数据点都是landmark
&lt;script type=&quot;math/tex&quot;&gt;x \rightarrow (e^{-\gamma||\boldsymbol x-\boldsymbol l_1||^2},e^{-\gamma||\boldsymbol x-\boldsymbol l_2||^2})&lt;/script&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;m \times n \rightarrow m \times m&lt;/script&gt;

&lt;p&gt;原本$n$维的数据升为$m$维（$m$为数据量）&lt;/p&gt;

&lt;p&gt;应用：自然语言处理&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;svm思想解决回归问题&quot;&gt;SVM思想解决回归问题&lt;/h2&gt;

&lt;p&gt;核心思想：在margin里包含的样本点越多越好&lt;/p&gt;

&lt;p&gt;超参数$\epsilon$指定margin到中间直线的距离&lt;/p&gt;
</description>
        <pubDate>Wed, 20 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/SVM.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/SVM.html</guid>
        
        <category>CODE</category>
        
        <category>MACHINELEARNING</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>聚类 Clustering —— K-means &amp; GMM</title>
        <description>&lt;h2 id=&quot;聚类性能度量&quot;&gt;聚类性能度量&lt;/h2&gt;

&lt;p&gt;聚类性能度量：聚类&lt;strong&gt;有效性指标&lt;/strong&gt;——簇内相似度高，簇间相似度低&lt;/p&gt;

&lt;p&gt;衡量指标包括外部指标/内部指标&lt;/p&gt;

&lt;p&gt;定义数据集$D={\boldsymbol x_1,\boldsymbol x_2,…,\boldsymbol x_m}$，通过聚类给出的簇划分为$C={C_1, C_2,…,C_k}$，参考模型给出的簇划分为$C^o={C_1^o, C_2^o,…,C_s^o}$，$\lambda$、$\lambda^o$为对应的簇$C$、$C^o$标记向量 ，其中$\lambda_j$的值表示$\boldsymbol x_j$在第几类，即$\boldsymbol x_j \in C_{\lambda_j}$。将样本两两配对，定义&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
a=|SS|, SS=\{(\boldsymbol{x}_i,\boldsymbol{x}_j)|\lambda_i=\lambda_j,\lambda_i^o=\lambda_j^o,i&lt;j\}\\
b=|SD|, SD=\{(\boldsymbol{x}_i,\boldsymbol{x}_j)|\lambda_i=\lambda_j,\lambda_i^o\neq\lambda_j^o,i&lt;j\}\\
c=|DS|, DS=\{(\boldsymbol{x}_i,\boldsymbol{x}_j)|\lambda_i\neq\lambda_j,\lambda_i^o=\lambda_j^o,i&lt;j\}\\
d=|DD|, DD=\{(\boldsymbol{x}_i,\boldsymbol{x}_j)|\lambda_i\neq\lambda_j,\lambda_i^o\neq\lambda_j^o,i&lt;j\}\\ %]]&gt;&lt;/script&gt;

&lt;p&gt;$SS$包含在$C$、$C^o$中均隶属于相同簇的样本对，$SD$包含在$C$属于同一簇，在$C^o$中隶属于不同簇的样本对。$SS$属于聚类完全正确，$DD$属于聚类结果正确。&lt;/p&gt;

&lt;p&gt;聚类性能度量外部指标：&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Jaccard系数 JC&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;JC=\frac{a}{a+b+c}&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;FM指数 FMI&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;FMI=\sqrt{\frac{a}{a+b}·\frac{a}{a+c}}&lt;/script&gt;

&lt;ul&gt;
  &lt;li&gt;&lt;strong&gt;Rand指数 RI&lt;/strong&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;RI=\frac{2(a+d)}{m(m-1)}&lt;/script&gt;

&lt;p&gt;结果值在$[0,1]$区间，值越大越好。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;k均值算法-k-means-&quot;&gt;K均值算法 &lt;em&gt;k-means&lt;/em&gt; 🥝&lt;/h2&gt;

&lt;p&gt;最小化平方误差&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;E=\sum_{i=1}^k\sum_{\boldsymbol{x}\in C_i}\|\boldsymbol{x}-\boldsymbol{\mu}_i\|_2^2&lt;/script&gt;

&lt;p&gt;其中$\boldsymbol \mu_i=\frac{1}{\vert C_i\vert}\sum_{\boldsymbol x\in C_i}\boldsymbol{x}$ 是簇$C_i$的均值向量(中心)，$E$刻画了簇内样本与中心$\boldsymbol{\mu}_i$的紧密程度。$E$越小，簇内样本相似度越高。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;../img/k-means.png&quot; alt=&quot;6&quot; style=&quot;zoom:60%;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;高斯混合聚类-gaussian-mixture-model--gmm-&quot;&gt;高斯混合聚类 Gaussian Mixture Model —— GMM 🥑&lt;/h2&gt;

&lt;p&gt;高斯分布概率密度：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;f(x)= \frac{1}{\sqrt {2 \pi} \sigma}e^{-\frac{(x-\mu)^2}{2\sigma^2}}&lt;/script&gt;

&lt;p&gt;多元高斯分布的概率密度函数：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p(\boldsymbol{x})=\frac{1}{(2\pi)^{\frac{n}{2}}|\boldsymbol{\Sigma}|^{\frac1{2}}}e^{-\frac{1}{2}(\boldsymbol{x}-\boldsymbol\mu)^T\boldsymbol{\Sigma}^{-1}(\boldsymbol{x}-\boldsymbol\mu)}&lt;/script&gt;

&lt;p&gt;其中$\mu$是$n$维均值向量，$\boldsymbol{\Sigma}$是$n\times n$的协方差矩阵。高斯分布完全由均值向量$\boldsymbol\mu$，协方差矩阵$\boldsymbol{\Sigma}$确定。将概率密度函数记为$p(\boldsymbol{x}\vert\boldsymbol{\mu}_i,\boldsymbol\Sigma_i)$，定义高斯混合分布如下&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p_\mathcal{M}(\boldsymbol{x})=\sum_{i=1}^k\alpha_i·p(\boldsymbol{x}|\boldsymbol\mu_i,\boldsymbol{\boldsymbol{\Sigma}}_i)&lt;/script&gt;

&lt;p&gt;高斯混合分布由$k$个&lt;strong&gt;混合成分&lt;/strong&gt;组成，每个混合成分对应一个高斯分布。其中$\mu_i$与$\boldsymbol \Sigma_i$是第$i$个高斯混合成分的参数，$\alpha_i&amp;gt;0$为相应的&lt;strong&gt;混合系数&lt;/strong&gt;，$\sum_{i=1}^k\alpha_i = 1$. 混合系数本质上是第$i$类样本所占整体样本的比例，从另一个角度看则是样本属于第$i$簇的概率。&lt;/p&gt;

&lt;p&gt;使用高斯混合分布的模型在样本空间中生成样本的过程：以$\alpha_1,\alpha_2,…,\alpha_k$作为概率选择出一个混合成分，根据该混合成分的概率密度函数，采样产生出相应的样本。&lt;/p&gt;

&lt;p&gt;给定样本集$D$，可使用&lt;strong&gt;极大似然估计&lt;/strong&gt;，即最大化对数似然函数&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
LL(D) &amp; = \ln \left( \prod \limits_{j=1}^mp_\mathcal{M}(\boldsymbol{x}_j) \right)\\ 
&amp; = \sum \limits_{j=1}^m \ln \sum_{i=1}^k\alpha_i·p(\boldsymbol{x}|\boldsymbol\mu_i, \boldsymbol{\Sigma}_i)
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;常用$EM$算法进行迭代优化求解&lt;/p&gt;

&lt;h3 id=&quot;期望最大化-expectation-maximization--em-&quot;&gt;期望—最大化 Expectation-Maximization —— EM 🥭&lt;/h3&gt;

&lt;p&gt;设训练集为$D={\boldsymbol{x}&lt;em&gt;1,\boldsymbol{x}_2,…,\boldsymbol{x}_m}$为高斯混合分布模型生成的样本，设$z_j$表示生成样本 $\boldsymbol{x}_j$的高斯混合成分，即$P(z_j=i)$对应于$\alpha_i(i=1,2,…,k)$。根据&lt;strong&gt;贝叶斯定理&lt;/strong&gt;，$z_j$的后验分布对应样本$\boldsymbol{x}_j$由第$i$个高斯混合分布成分生成的&lt;strong&gt;后验概率&lt;/strong&gt;，简记为$\gamma&lt;/em&gt;{ji}$&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}
\gamma_{ji}= p_\mathcal{M}(z_j=i|\boldsymbol{x}_j) &amp;= \frac{P(z_j=i)·p_\mathcal{M}(\boldsymbol{x}_j|z_j=i)}{p_\mathcal{M}(\boldsymbol{x}_j)} \\
&amp; = \frac{\alpha_i·p(\boldsymbol{x}_j|\boldsymbol\mu_i,\boldsymbol\Sigma_i)}{\sum\limits_{l=1}^k\alpha_l·p(\boldsymbol{x}_j|\boldsymbol\mu_l,\boldsymbol\Sigma_l)}
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;$\gamma_{ji}$是已知样本为$\boldsymbol{x}_j$，反推该样本属于第$i$类的概率。把$\boldsymbol{x}_j$暂时划分到概率最大的那一类，则样本$\boldsymbol{x}_j$的簇标记$\lambda_j$为&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\lambda_j = \mathop{\arg\max} \limits_{i\in{1,2,...,k}} \gamma_{ji}&lt;/script&gt;

&lt;p&gt;若参数${(\alpha_i,\boldsymbol\mu_i,\boldsymbol{\Sigma}_i)}$能使似然函数最大化，由$\frac{\partial LL(D)}{\partial \boldsymbol\mu_i}= 0$有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\boldsymbol \mu_i = \frac{\sum \limits_{j=1}^m \gamma_{ji} \boldsymbol x_j}{\sum \limits_{j=1}^m \gamma_{ji}} \tag{1}&lt;/script&gt;

&lt;p&gt;由$\frac{\partial LL(D)}{\partial \boldsymbol\Sigma_i}= 0$有&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\mathbf\Sigma_{i}=\cfrac{\sum \limits_{j=1}^m\gamma_{ji}(\boldsymbol x_{j}-\boldsymbol \mu_{i})(\boldsymbol x_{j}-\boldsymbol\mu_{i})^T}{\sum \limits_{j=1}^m\gamma_{ji}}\tag{2}&lt;/script&gt;

&lt;p&gt;每个高斯成分的混合系数由该成分的平均后验概率确定&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\alpha_i=\frac{1}{m}\sum \limits_{j=1}^m \gamma_{ji}\tag{3}&lt;/script&gt;

&lt;p&gt;EM算法：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;E步：根据当前参数计算属于每个高斯成分的后验概率$\gamma_{ji}$&lt;/li&gt;
  &lt;li&gt;M步：根据$(1)(2)(3)$更新${(\alpha_i,\boldsymbol\mu_i,\boldsymbol{\Sigma}_i)\vert1\leq i \leq k}$&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;p&gt;&lt;img src=&quot;../img/GMM.png&quot; style=&quot;zoom:60%;&quot; /&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;初始化方案：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;协方差矩阵$\boldsymbol{\Sigma}_i$设为单位矩阵，每个模型比例的先验概率$\alpha_i = 1/k$，均值$\boldsymbol\mu_i$设为随机数&lt;/li&gt;
  &lt;li&gt;由k-means聚类算法对样本进行聚类，利用各类的均值作为$\boldsymbol\mu_i$，并计算$\boldsymbol{\Sigma}_i$，$\alpha_i$取各类样本占样本总数的比例&lt;/li&gt;
&lt;/ol&gt;
</description>
        <pubDate>Wed, 20 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/%E8%81%9A%E7%B1%BB-Clustering-K-means-&-GMM.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/%E8%81%9A%E7%B1%BB-Clustering-K-means-&-GMM.html</guid>
        
        <category>CODE</category>
        
        <category>MACHINELEARNING</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>🌲 决策树</title>
        <description>&lt;p&gt;构建决策树之通常包括三个步骤：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;特征选择&lt;/li&gt;
  &lt;li&gt;决策树生成&lt;/li&gt;
  &lt;li&gt;决策树剪枝&lt;/li&gt;
&lt;/ol&gt;

&lt;h2 id=&quot;决策树生成&quot;&gt;决策树生成&lt;/h2&gt;

&lt;h3 id=&quot;信息增益&quot;&gt;信息增益&lt;/h3&gt;

&lt;p&gt;通常使用&lt;strong&gt;信息熵&lt;/strong&gt;Information Entropy度量样本集合纯度。样本集合为$D$，第$k$类样本所占比例为$p_k(k=1,2,…,N)$，则样本$D$的信息熵为&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;H(D) =-\sum\limits_{k=1}^{N}p_k{\log}_2p_k&lt;/script&gt;

&lt;p&gt;$Ent(D)$越小，$D$的纯度越高。&lt;/p&gt;

&lt;p&gt;设离散属性$a$有$V$个可能的取值，当用属性$a$对样本集合$D$进行划分所获的的&lt;strong&gt;信息增益&lt;/strong&gt;Information Gain为目标类变量与属性&lt;script type=&quot;math/tex&quot;&gt;a&lt;/script&gt;变量在&lt;script type=&quot;math/tex&quot;&gt;D&lt;/script&gt;(样本集)上的&lt;strong&gt;互信息&lt;/strong&gt;。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Gain(D,a)=H(D)- \sum \limits_{v=1}^V\frac{|D^v|}{|D|}H(D^v)&lt;/script&gt;

&lt;p&gt;一般而言，信息增益越大，意味着使用属性$a$进行划分获得的纯度提升越大。&lt;/p&gt;

&lt;p&gt;ID3选择属性使用信息增益&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;a_* = \mathop{ \arg \max}\limits_{a \in A} Gain(D,a)&lt;/script&gt;

&lt;h3 id=&quot;增益率&quot;&gt;增益率&lt;/h3&gt;

&lt;p&gt;信息增益更偏好于&lt;strong&gt;可取更多的值属性&lt;/strong&gt;，为减小这种偏好的影响，在C4.5选择属性使用&lt;strong&gt;增益率&lt;/strong&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Gain\_ratio(D,a)=\frac{Gain(D,a)}{IV(a)}&lt;/script&gt;

&lt;p&gt;$IV(a)$为属性$a$的&lt;strong&gt;固有值&lt;/strong&gt;Intrinsic Value。属性$a$可取值越多，$IV(a)$的值通常会越大。&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;IV(a)=-\sum \limits_{v=1}^V\frac{|D^v|}{|D|}\log_2\frac{|D^v|}{|D|}&lt;/script&gt;

&lt;p&gt;个人理解$IV(a)$即计算按属性$a$分类时的信息熵，属性$a$多时混乱程度通常更大，导致信息增益更大。&lt;/p&gt;

&lt;p&gt;C4.5先从候选划分属性中找出信息增益高于平均水平的属性，再从中选择信息增益率最高的。&lt;/p&gt;

&lt;h3 id=&quot;基尼指数&quot;&gt;基尼指数&lt;/h3&gt;

&lt;p&gt;CART决策树使用&lt;strong&gt;基尼指数&lt;/strong&gt;选择划分属性，数据集$D$的纯度可用&lt;strong&gt;基尼值&lt;/strong&gt;度量&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Gini(D)=\sum_{k=1}^N\sum_{k'\neq k}p_kp_{k'} = 1-\sum_{k=1}^N p_k^2&lt;/script&gt;

&lt;p&gt;直观来说，$Gini(D)$反映了从数据集$D$中随机抽取两个样本，其类别标记不一致的概率，因此$Gini(D)$越小，则数据集$D$纯度越高。&lt;/p&gt;

&lt;p&gt;$Gini$在节点取值分布均匀时取最大值$1-1/V$，在只包含一个类别时取最小值$0$。
属性$a$的基尼指数定义为&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;𝐺𝑖𝑛𝑖\_𝑖𝑛𝑑𝑒𝑥(𝐷,𝑎)=\sum \limits_{𝑣=1}^𝑉\frac{|D^v|}{|D|}𝐺𝑖𝑛𝑖(𝐷^𝑣)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;a_* = \mathop{ \arg \min}\limits_{a \in A} Gini\_index(D,a)&lt;/script&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;决策树剪枝&quot;&gt;决策树剪枝&lt;/h2&gt;

&lt;p&gt;&lt;strong&gt;剪枝&lt;/strong&gt;pruning是决策树学习算法中避免过拟合的主要手段。&lt;/p&gt;

&lt;h3 id=&quot;预剪枝&quot;&gt;预剪枝&lt;/h3&gt;

&lt;p&gt;​		在决策树生成过程中，对每个结点划分前进行估计，若对此结点划分不能带来决策树泛化性能的提升，则停止划分并标记为叶子结点。&lt;/p&gt;

&lt;p&gt;​		预剪枝使得决策树的很多分支都没有展开，这不仅降低了过拟合的风险，还显著减少了决策树训练和预测的时间开销。&lt;/p&gt;

&lt;p&gt;​		但是另一方面，有些分支的当前划分虽然不能带来泛化性能的提升，甚至可能导致泛化性能暂时下降，但在其基础上进行的后续划分却有可能导致泛化性能显著上升。所以基于贪心策略的预剪枝可能带来欠拟合的风险。&lt;/p&gt;

&lt;h3 id=&quot;后剪枝&quot;&gt;后剪枝&lt;/h3&gt;

&lt;p&gt;首先生成完整的决策树，然后自下而上地逐层剪枝，如果一个节点的子节点被删除后，决策树的准确度没有降低，那么就将该节点设置为叶节点。训练时间开销大。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;连续和缺失值&quot;&gt;连续和缺失值&lt;/h2&gt;

&lt;h3 id=&quot;属性值连续&quot;&gt;属性值连续&lt;/h3&gt;

&lt;p&gt;对于连续的属性而言，属性值可取分界点后构成二分法的分类。分界点的取值同样是两点的中点值，对中点值进行分类增益计算后再进行比较。连续值在子节点上依然能够再次进行分类。&lt;/p&gt;

&lt;h3 id=&quot;样本值缺失&quot;&gt;样本值缺失&lt;/h3&gt;

&lt;p&gt;对于训练决策树时训练集存在某些特征的属性值缺失的情况，会遇到如下两个问题：&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;如何选择最优属性进行划分&lt;/li&gt;
  &lt;li&gt;给定划分属性，若在该属性上值缺失，如何确定样本的归属&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;对于问题1而言：只要将所有的计算换成无缺样本的数据即可。最终增益乘以对应特征所含有值的概率值，&lt;/p&gt;

&lt;p&gt;对于问题2而言：将缺失值的样本按照一定的比例以不同的概率划分到不同的子节点中去。若取值已知，则划分到对应的子节点中去，样本权值在子节点中保持为wx，若取值未知，则将x同时划入所有的子节点中区，并将样本去找你之在对应中调整为对应的比例乘以wx，权重在之后则以概率的形式体现到计算中去。&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;多变量决策树&quot;&gt;多变量决策树&lt;/h2&gt;

&lt;p&gt;多变量决策树的学习过程中，不是为每个非叶节点寻找一个最优划分属性，而是试图建立一个合适的线性分类器于一个节点中，减缓决策树的复杂度。&lt;/p&gt;
</description>
        <pubDate>Sun, 10 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/%E5%86%B3%E7%AD%96%E6%A0%91.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/%E5%86%B3%E7%AD%96%E6%A0%91.html</guid>
        
        <category>CODE</category>
        
        <category>MACHINELEARNING</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>逻辑回归 Logitstic Regression</title>
        <description>&lt;h2 id=&quot;对数几率回归-logitstic-regression&quot;&gt;对数几率回归 Logitstic Regression&lt;/h2&gt;

&lt;p&gt;考虑二分类任务，将线性回归模型的预测值$h(\boldsymbol x) =\boldsymbol{w}^T\boldsymbol{x} + b$转换为0/1值&lt;/p&gt;

&lt;h3 id=&quot;对数几率函数-sigmoid&quot;&gt;对数几率函数 Sigmoid&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;y = \frac{1}{1+e^{-z}}&lt;/script&gt;

&lt;p&gt;&lt;img src=&quot;../img/Sigmoid.png&quot; style=&quot;zoom:38%;&quot; /&gt;&lt;/p&gt;

&lt;p&gt;当$z&amp;gt;0$时，$Sigmoid&amp;gt;0$，且$z$越大，$Sigmoid$越接近$1$；$z&amp;lt;0$时，$Sigmoid&amp;lt;0$，$z$越小，$Sigmoid$越接近$0$。&lt;/p&gt;

&lt;p&gt;将$h(\boldsymbol x)$代入，可将预测值转换为0/1值，得&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\hat y = \frac{1}{1+e^{-(\boldsymbol{w}^T\boldsymbol{x}+b)}}&lt;/script&gt;

&lt;p&gt;线性模型可表示为&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;h =\boldsymbol{w}^T\boldsymbol{x} + b = \ln \frac{y}{1-y}&lt;/script&gt;

&lt;p&gt;设$y$为样本$\boldsymbol{x}$为正例的可能性，即后验概率估计$p(y=1{\vert}\boldsymbol{x})$，$1-y$为反例的可能性&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\hat y = \frac{1}{1+e^{-(\boldsymbol{w}^T\boldsymbol{x}+b)}}&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ln \frac{y}{1-y}=\boldsymbol{w}^T\boldsymbol{x}+b = \ln \frac{p(y=1|\boldsymbol{x})}{p(y=0|\boldsymbol{x})}&lt;/script&gt;

&lt;p&gt;其中$\frac{y}{1-y}$为&lt;strong&gt;几率&lt;/strong&gt;odds，$\ln \frac{y}{1-y}$为&lt;strong&gt;对数几率&lt;/strong&gt;logit&lt;/p&gt;

&lt;p&gt;概率分布如下&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;p(y=1|\boldsymbol{x}) = \frac{e^{\boldsymbol{w}^T\boldsymbol{x}+b}}{1+e^{\boldsymbol{w}^T\boldsymbol{x}+b}}\\
p(y=0|\boldsymbol{x}) = \frac{1}{1+e^{\boldsymbol{w}^T\boldsymbol{x}+b}}&lt;/script&gt;

&lt;p&gt;可通过&lt;strong&gt;极大似然法&lt;/strong&gt;估计$\boldsymbol{w}$和$b$，设数据集为${(\boldsymbol{x_i},y_i)}_{i-1}^m$&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\ln L(\boldsymbol{w},b)=\sum _{i=1}^m \ln p(y_i|\boldsymbol{x}_i;\boldsymbol{w},b)&lt;/script&gt;

&lt;h3 id=&quot;代价函数-cost-function&quot;&gt;代价函数 Cost Function&lt;/h3&gt;

&lt;p&gt;由于的$Sigmoid$函数使之前使用的代价函数成为非凸函数，定义新代价函数为&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Cost(\hat y (x),y) = 
\left\{
 \begin{array}{**}
-\log(\hat y) , y = 1 \\
-\log(1-\hat y) , y = 0
\end{array}
\right. 
 = -y\log(\hat y)-(1-y)\log(1-\hat y)&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}{}
Loss&amp; =\frac{1}{m}\sum_{i=1}^mCost(\hat y ^{(i)},y^{(i)}) \\
&amp; = -\frac{1}{m}\sum_{i=1}^m [y^{(i)}\log\hat y ^{(i)}+(1-y^{(i)})\log(1-\hat y ^{(i)}) ]
\end{align} %]]&gt;&lt;/script&gt;

&lt;p&gt;$Loss$的导数化简结果如下：
&lt;script type=&quot;math/tex&quot;&gt;Loss(\boldsymbol \theta)= -\frac{1}{m}\sum_{i=1}^m [y^{(i)}\log\frac{1}{1+e^{-\boldsymbol{\theta}^T\boldsymbol{x}}}+(1-y^{(i)})\log(1-\frac{1}{1+e^{-\boldsymbol{\theta}^T\boldsymbol{x}}} ]&lt;/script&gt;&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\frac{\partial Loss}{\partial \boldsymbol \theta_j} = 
\frac{1}{m}\sum_{i=1}^m(\hat y^{(i)}-y^{(i)})x_j^{(i)}&lt;/script&gt;

&lt;h3 id=&quot;梯度下降-gradient-descent&quot;&gt;梯度下降 Gradient Descent&lt;/h3&gt;

&lt;p&gt;如果$Loss(\boldsymbol w )$如果在$\boldsymbol w_i$点可微且有定义，梯度 $\nabla Loss(\boldsymbol w _i)$为函数增长最快的方向，因此梯度的反方向$-\nabla Loss(\boldsymbol w _i)$为函数下降最快的方向。设$\alpha$为学习率，可以用以下公式进行迭代：&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;% &lt;![CDATA[
\begin{align}{}
\boldsymbol w _{i+1}&amp; = \boldsymbol w _i − α \nabla Loss(\boldsymbol w _i)\\
&amp; = \boldsymbol w _i − α \frac{\partial}{\partial\boldsymbol w _i}Loss(\boldsymbol w) \\
&amp; = \boldsymbol w _i − α \frac{1}{m} \sum_{j=1}^m (\hat y^{(j)}-y^{(j)})x_i^{(j)} 
\end{align} %]]&gt;&lt;/script&gt;

&lt;h3 id=&quot;正则化&quot;&gt;正则化&lt;/h3&gt;

&lt;p&gt;向代价函数中加入L2正则项&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;Loss =\frac{1}{m}\sum_{i=1}^m [Cost(\hat y (x)^{(i)},y^{(i)})+\lambda \sum \limits_{j=1}^n \boldsymbol w^2_j]&lt;/script&gt;

&lt;p&gt;梯度下降法迭代公式为&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\boldsymbol w _{i+1}= \boldsymbol w _i − α \frac{1}{m} \sum_{j=1}^m (\hat y(x^{(j)})-y^{(j)})x_i^{(j)} + \frac{\lambda}{m}\boldsymbol w _i&lt;/script&gt;

&lt;h3 id=&quot;优化目标&quot;&gt;优化目标&lt;/h3&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\min_\theta \frac{1}{m} \left[ \sum_{i=1}^m y^{(i)}\log(h_{\theta}(x^{(i)}))+(1-y^{(i)})\log(1-h_{\theta}(x^{(i)}))\right]+\frac{\lambda}{2m}\sum_{j=1}^n\theta_j^2&lt;/script&gt;

</description>
        <pubDate>Fri, 08 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/%E9%80%BB%E8%BE%91%E5%9B%9E%E5%BD%92.html</guid>
        
        <category>CODE</category>
        
        <category>MACHINELEARNING</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>线性回归</title>
        <description>&lt;h2 id=&quot;线性模型&quot;&gt;线性模型&lt;/h2&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\boldsymbol w = \left[\begin{matrix}        w_1 \\    w_2\\  \vdots\\     w_n\end{matrix}\right],
\boldsymbol x = \left[\begin{matrix}     x_1  \\     x_2 \\       \vdots\\     x_n\end{matrix}\right] \rightarrow f(x) = w_1x_1+ w_2x_2+ ... + w_nx_n+b = \boldsymbol w^T \boldsymbol x+b&lt;/script&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;\boldsymbol \theta = \left[\begin{matrix}     b  \\     w_1 \\    w_2\\  \vdots\\     w_n\end{matrix}\right],
\boldsymbol x = \left[\begin{matrix}   1\\   x_1  \\     x_2 \\       \vdots\\     x_n\end{matrix}\right] \rightarrow f(x)= \boldsymbol \theta^T \boldsymbol x&lt;/script&gt;

&lt;h2 id=&quot;线性回归&quot;&gt;线性回归&lt;/h2&gt;

&lt;p&gt;目标：&lt;strong&gt;均方误差&lt;/strong&gt;$MSE$（$Mean\ Squared\ Error$）最小化，即&lt;/p&gt;

&lt;script type=&quot;math/tex; mode=display&quot;&gt;(w^*,b^*) = \mathop {\arg\min}_{(w,b)}\sum_{i=1}^m(f(x_i)-y_i)^2&lt;/script&gt;

&lt;p&gt;基于均方误差最小化的模型求解方法为&lt;strong&gt;最小二乘法&lt;/strong&gt;：试图找到一条线，使所有样本到直线上的欧式距离之和最小，求解过程为&lt;strong&gt;参数估计&lt;/strong&gt;。&lt;/p&gt;

</description>
        <pubDate>Fri, 01 Nov 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/%E7%BA%BF%E6%80%A7%E5%9B%9E%E5%BD%92.html</guid>
        
        <category>CODE</category>
        
        <category>MACHINELEARNING</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>Java一些有趣的小问题总结</title>
        <description>&lt;h2 id=&quot;java内部类访问局部变量必须声明为final&quot;&gt;Java内部类访问局部变量必须声明为final？&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static void main(String[] args) {
  String str = &quot;haha&quot;;
  // str = &quot;test&quot;;
  new Thread() {
    @Override
    public void run() {
      System.out.println(str);
    }
  }.start();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;以上代码能够通过编译正常运行，取消注释后编译不通过，报错如下：&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Local variable str defined in an enclosing scope must be final or effectively
final&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;即Java内部类访问局部变量必须声明为final &lt;br /&gt; Java一开始没有报错是默认认为变量为final，若变量被修改过，则默认的假设不成立，Java报错。&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;内部类的生命周期比局部变量的长，故定义str时JVM做了程序员看不到的操作：将str拷贝了一份给局部内部类，也就是说JVM在局部内部类中定义了一个&lt;code class=&quot;highlighter-rouge&quot;&gt;final String str = &quot;haha&quot;;&lt;/code&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;判断奇偶数&quot;&gt;判断奇偶数&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean isOdd(int i) {
return i % 2 == 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;使用&lt;code class=&quot;highlighter-rouge&quot;&gt;x % 2 == 1&lt;/code&gt;的方式判断奇偶性对负数无效 &lt;br /&gt; Spotbugs指出：
If this code is intending to check for oddness, consider using &lt;code class=&quot;highlighter-rouge&quot;&gt;x &amp;amp; 1 == 1&lt;/code&gt;, or &lt;code class=&quot;highlighter-rouge&quot;&gt;x % 2 != 0&lt;/code&gt;.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public boolean isOdd(int i) {
return (i &amp;amp; 1) == 1;
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;字符串去哪儿了&quot;&gt;字符串去哪儿了？&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String a = &quot;a&quot;;
String b = &quot;a&quot;;
System.out.println(&quot;a and b: &quot; + a == b);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;ol&gt;
    &lt;li&gt;’+’ 的运算优先级’==’ 高     ‘&amp;amp;&amp;amp;’ 优先级比 ‘||’ 高 &lt;br /&gt;&lt;/li&gt;
    &lt;li&gt;equals() 和 ==&lt;/li&gt;
  &lt;/ol&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;integer为什么不相等&quot;&gt;Integer为什么不相等？&lt;/h2&gt;
&lt;h3 id=&quot;plan-a--使用constructor生成integer&quot;&gt;Plan A — 使用constructor生成Integer&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Integer a = new Integer(200);
Integer b = new Integer(200);
System.out.println(a == b);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;’==’ 判断是否指向同一对象&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;plan-b--使用valueof生成integer&quot;&gt;Plan B — 使用valueOf生成Integer&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Integer a = Integer.valueOf(200);
Integer b = Integer.valueOf(200);
System.out.println(a == b);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h3 id=&quot;plan-c--直接生成integer&quot;&gt;Plan C — 直接生成Integer&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Integer a = 200, b = 200;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Integer a = 200&lt;/code&gt;的时候，会自动调用&lt;code class=&quot;highlighter-rouge&quot;&gt;Integer&lt;/code&gt;中的&lt;code class=&quot;highlighter-rouge&quot;&gt;valueOf()&lt;/code&gt;方法，故&lt;code class=&quot;highlighter-rouge&quot;&gt;Integer a = 200;&lt;/code&gt; 和 &lt;code class=&quot;highlighter-rouge&quot;&gt;Integer a = Integer.valueOf(200);&lt;/code&gt;等同&lt;/p&gt;

&lt;h3 id=&quot;从200变为2结果却不一样&quot;&gt;从200变为2，结果却不一样？&lt;/h3&gt;
&lt;h4 id=&quot;plan-b&quot;&gt;Plan B:&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Integer a = Integer.valueOf(2);
Integer b = Integer.valueOf(2);
System.out.println(a == b);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;plan-c&quot;&gt;Plan C:&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Integer a=2, b=2;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;查看&lt;code class=&quot;highlighter-rouge&quot;&gt;valueOf()&lt;/code&gt;的源码如下：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public static Integer valueOf(int i) {
  if (i &amp;gt;= IntegerCache.low &amp;amp;&amp;amp; i &amp;lt;= IntegerCache.high)
    return IntegerCache.cache[i + (-IntegerCache.low)];
  return new Integer(i);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;valueOf()&lt;/code&gt;在返回之前，会进行判断，判断当前i的值是否在 &lt;code class=&quot;highlighter-rouge&quot;&gt;-128~127&lt;/code&gt;之间。如果存在，则直接返回一个缓存的引用，不再重新开辟内存空间。
如果不存在，就创建一个新的对象&lt;code class=&quot;highlighter-rouge&quot;&gt;new Integer()&lt;/code&gt;。
&lt;br /&gt;
 &lt;code class=&quot;highlighter-rouge&quot;&gt;Integer&lt;/code&gt;存在缓存类&lt;code class=&quot;highlighter-rouge&quot;&gt;IntegerCache&lt;/code&gt;，而缓存类会在第一次加载时初始化一个&lt;code class=&quot;highlighter-rouge&quot;&gt;Integer缓存数组&lt;/code&gt;，这个数组大小不是固定的，但是一定大于或等于256，覆盖范围为[-128,127]。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;integercache大小修改&quot;&gt;IntegerCache大小修改&lt;/h3&gt;

&lt;p&gt;cache的大小可以通过jvm指令修改：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-XX:AutoBoxCacheMax==&amp;lt;size&amp;gt;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;除&lt;code class=&quot;highlighter-rouge&quot;&gt;float&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;double&lt;/code&gt;以外的&lt;code class=&quot;highlighter-rouge&quot;&gt;所有基础数据类型对应的封装类型&lt;/code&gt;都实现了缓存。他们缓存都是通过&lt;code class=&quot;highlighter-rouge&quot;&gt;valueOf()&lt;/code&gt;静态工厂完成的。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;的位置影响结果&quot;&gt;++的位置影响结果&lt;/h3&gt;
&lt;p&gt;Test&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Integer a = new Integer(2);
Integer b = new Integer(2);
System.out.println(a++ == b++);
System.out.println(++a == ++b);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;false
true
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;++a和++b是&lt;code class=&quot;highlighter-rouge&quot;&gt;autoboxing&lt;/code&gt;之后的结果 用到了cache&lt;br /&gt;
a++和b++是原来Integer的结果&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;被哪里捕捉了&quot;&gt;被哪里捕捉了?&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;try {
  try{
    FileInputStream p = new FileInputStream(&quot;a.txt&quot;);
  }catch(FileNotFoundException e) {
    System.out.println(&quot;a&quot;);
  }
}catch(Exception e) {
  System.out.println(&quot;b&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Output:
a
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;try catch嵌套时若内层catch能捕获，则外层catch不执行。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;finally-vs-return&quot;&gt;finally vs return&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;boolean func() {
  try {
    return true;
  } finally {
    return false;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Result:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;false
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;类型参数命名惯例&quot;&gt;类型参数命名惯例&lt;/h2&gt;

&lt;blockquote&gt;
  &lt;p&gt;By convention, type parameter names are single, uppercase letters. This stands in sharp contrast to the variable naming conventions that you already know about, and with good reason: Without this convention, it would be difficult to tell the difference between a type variable and an ordinary class or interface name.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最常用的类型参数命名如下:&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;E - Element (used extensively by the Java Collections Framework)&lt;/li&gt;
  &lt;li&gt;K - Key&lt;/li&gt;
  &lt;li&gt;N - Number&lt;/li&gt;
  &lt;li&gt;T - Type&lt;/li&gt;
  &lt;li&gt;V - Value&lt;/li&gt;
  &lt;li&gt;S,U,V etc. - 2nd, 3rd, 4th types&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;调用了哪个方法&quot;&gt;调用了哪个方法？&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class A {
  void foo() {
    this.bar();
  }
  void bar() {
    print(&quot;A.bar&quot;);
  }
}

class B extends A {
  void foo() {
    super.foo();
  }
  void bar() {
    print(&quot;B.bar&quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;B.bar
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;B中的&lt;code class=&quot;highlighter-rouge&quot;&gt;foo()&lt;/code&gt;override了A中的&lt;code class=&quot;highlighter-rouge&quot;&gt;foo()&lt;/code&gt;&lt;/p&gt;
&lt;blockquote&gt;
  &lt;p&gt;Overridden的实例方法被调用的是子类型中的。&lt;br /&gt;区分于hidden的情况（hide适用于field和静态方法）
hidden的静态方法被调用的是哪一个取决于它被调用的位置（子类型还是父类型）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Test {
  public static void main(String[] args) {
    new B().foo();
  }
}

class A {
  void foo() {
    barStatic();
  }
  static void barStatic() {
    System.out.println(&quot;A.barStatic&quot;);
  }
}

class B extends A {
  void foo() {
    super.foo();
  }
  static void barStatic() {
    System.out.println(&quot;B.barStatic&quot;);
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Output:&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;A.barStatic
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;返回值协变&quot;&gt;返回值协变&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;interface A {
  public C build(...);
}
class B implements A {
  public D build(...) {
    ...
  }
}
其中D是C的子类型

客户端：
C c = new B().create();
此时c的运行时类型其实是D

接口和类之间的override同样可以covariance。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;catch-exception-的顺序问题&quot;&gt;catch Exception 的顺序问题&lt;/h2&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;try {
  FileInputStream p = new FileInputStream(&quot;a.txt&quot;);
}catch(Exception e) {
  System.out.println(&quot;exception&quot;);
}catch(FileNotFoundException e) {
  System.out.println(&quot;file not found exception&quot;);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;blockquote&gt;
  &lt;p&gt;Unreachable catch block for FileNotFoundException. It is already handled by the catch block for Exception&lt;/p&gt;
&lt;/blockquote&gt;

</description>
        <pubDate>Sun, 23 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/Java%E7%BB%86%E8%8A%82%E6%80%BB%E7%BB%93.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/Java%E7%BB%86%E8%8A%82%E6%80%BB%E7%BB%93.html</guid>
        
        <category>SOFTWARE-CONSTRUCTION</category>
        
        <category>JAVA</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>Java中-able总结</title>
        <description>&lt;h2 id=&quot;java中-able总结&quot;&gt;Java中-able总结&lt;/h2&gt;

&lt;ul&gt;
  &lt;li&gt;Comparable &amp;amp; Comparator&lt;/li&gt;
  &lt;li&gt;Iterable &amp;amp; Iterator&lt;/li&gt;
  &lt;li&gt;Observable &amp;amp; Observer&lt;/li&gt;
  &lt;li&gt;Throwable&lt;/li&gt;
  &lt;li&gt;Cloneable&lt;/li&gt;
  &lt;li&gt;Runnable&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;comparable--comparator&quot;&gt;Comparable &amp;amp; Comparator&lt;/h3&gt;

&lt;h4 id=&quot;comparable&quot;&gt;Comparable&lt;/h4&gt;
&lt;p&gt;需override&lt;code class=&quot;highlighter-rouge&quot;&gt;compareTo()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Person implements Comparable&amp;lt;Person&amp;gt; {
   @Override
   public int compareTo(Person o) {
     if (...) return -1;
     else if (...) return 1;
     else return 0;
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;comparator&quot;&gt;Comparator&lt;/h4&gt;
&lt;p&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparator&lt;/code&gt;是策略模式&lt;code class=&quot;highlighter-rouge&quot;&gt;strategy design pattern&lt;/code&gt;，可使用不同的Comparator对象实现不同策略的排序。
需override&lt;code class=&quot;highlighter-rouge&quot;&gt;compare()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class Cmp implements Comparator {
  @Override
  public int compare(Object arg0, Object arg1) {
    Person a = (Person) arg0;
    Person b = (Person) arg1;
    if (...) return -1;
    else if (...) return 1;
    else return 0;
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;调用方法：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Person[] p = new Person[4];
Arrays.sort(p);//默认排序
Arrays.sort(p, new Cmp());//自定义排序
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;summary&quot;&gt;Summary&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;顾名思义，某个class实现&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparable&lt;/code&gt;可以使该class的对象可比较：&lt;code class=&quot;highlighter-rouge&quot;&gt;a.compareTo(b)&lt;/code&gt;&lt;/li&gt;
  &lt;li&gt;&lt;code class=&quot;highlighter-rouge&quot;&gt;Comparator&lt;/code&gt;为比较器和一种比较策略，内部需override&lt;code class=&quot;highlighter-rouge&quot;&gt;compare()&lt;/code&gt;方法&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;iterable--iterator&quot;&gt;Iterable &amp;amp; Iterator&lt;/h3&gt;

&lt;h4 id=&quot;iterator&quot;&gt;Iterator&lt;/h4&gt;
&lt;p&gt;Iterator的定义：包含&lt;code class=&quot;highlighter-rouge&quot;&gt;hasNext()&lt;/code&gt;，&lt;code class=&quot;highlighter-rouge&quot;&gt;next()&lt;/code&gt;和&lt;code class=&quot;highlighter-rouge&quot;&gt;remove()&lt;/code&gt;方法。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Iterator {  
　　boolean hasNext();  
　　Object next();  
　　void remove();  
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Iterator的使用：&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Iterator iter = l.iterator();
while(iter.hasNext()){
    String str = (String) iter.next();
    System.out.println(str);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;iterable&quot;&gt;Iterable&lt;/h4&gt;

&lt;p&gt;Iterabler的定义：包含&lt;code class=&quot;highlighter-rouge&quot;&gt;iterator()&lt;/code&gt;方法。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Iterable&amp;lt;T&amp;gt; {
  Iterator&amp;lt;T&amp;gt; iterator();
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;Iterable的使用：override&lt;code class=&quot;highlighter-rouge&quot;&gt;iterator()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class ArrayMap&amp;lt;K, V&amp;gt; implements Iterable&amp;lt;K&amp;gt; {
  @Override
  public Iterator&amp;lt;K&amp;gt; iterator() {
      return new KeyIterator();
  }
}

public class KeyIterator implements Iterator&amp;lt;K&amp;gt; {
  @Override
  public boolean hasNext() {
      ...
  }
  @Override
  public K next() {
      ...
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;observable--observer&quot;&gt;Observable &amp;amp; Observer&lt;/h3&gt;

&lt;h4 id=&quot;observer&quot;&gt;Observer&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public interface Observer {
  void update(Observable o, Object arg);
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;h4 id=&quot;observerable&quot;&gt;Observerable&lt;/h4&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class NumObservable extends Observable {
  private int data = 0;
  public int getData() {
     return data;
  }
  public void setData(int i) {
     data = i;
     setChanged();
     notifyObservers();
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;被观察者&lt;code class=&quot;highlighter-rouge&quot;&gt;NumObserable&lt;/code&gt;执行了&lt;code class=&quot;highlighter-rouge&quot;&gt;notifyObservers()&lt;/code&gt;后，观察者执行&lt;code class=&quot;highlighter-rouge&quot;&gt;update()&lt;/code&gt;方法。&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class NumObserver implements Observer {

  @Override
  public void update(Observable o, Object arg) {
    NumsObservable myObserable = (NumsObservable) o;
    System.out.println(&quot;Data has changed to &quot; + myObserable.getData());
  }

}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;throwable&quot;&gt;Throwable&lt;/h3&gt;
&lt;p&gt;This is a &lt;strong&gt;class&lt;/strong&gt;, not interface.&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyException_another extends Throwable {
   private static final long serialVersionUID = 1L;
   public MyException_another() {
     super();
   }
   public MyException_another(String msg) {
     super(msg);
   }
   public MyException_another(String msg, Throwable cause) {
     super(msg, cause);
   }
   public MyException_another(Throwable cause) {
     super(cause);
   }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;cloneable&quot;&gt;Cloneable&lt;/h3&gt;
&lt;p&gt;需重写&lt;code class=&quot;highlighter-rouge&quot;&gt;clone()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public class Test implements Cloneable {
  @Override
  protected Object clone() throws CloneNotSupportedException {
      ...
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;runnable&quot;&gt;Runnable&lt;/h3&gt;

&lt;p&gt;需重写&lt;code class=&quot;highlighter-rouge&quot;&gt;run()&lt;/code&gt;方法&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyThread1 implements Runnable {
  @Override
  public synchronized void  run() {
    ...
  }
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 20 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/interface%E6%80%BB%E7%BB%93.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/interface%E6%80%BB%E7%BB%93.html</guid>
        
        <category>CODE</category>
        
        <category>SOFTWARECONSTRUCTION</category>
        
        <category>JAVA</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>面向性能的构造技术</title>
        <description>&lt;h2 id=&quot;metrics&quot;&gt;Metrics&lt;/h2&gt;
&lt;h3 id=&quot;time-performance&quot;&gt;Time performance&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;get execution time&lt;/p&gt;

    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; System.currentTimeMillis()
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Basic statements&lt;/li&gt;
  &lt;li&gt;Algorithms&lt;/li&gt;
  &lt;li&gt;Data structure&lt;/li&gt;
  &lt;li&gt;I/O (file, database, network communication, etc)&lt;/li&gt;
  &lt;li&gt;Concurrency / multi-thread / lock
    &lt;h3 id=&quot;space-performance&quot;&gt;Space performance&lt;/h3&gt;
  &lt;/li&gt;
  &lt;li&gt;Get memory consumption
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;// Get the Java runtime
Runtime runtime = Runtime.getRuntime();
// Run the garbage collector
runtime.gc();
// Calculate the used memory
long memory = runtime.totalMemory() - runtime.freeMemory();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;Algorithms&lt;/li&gt;
  &lt;li&gt;Data structure&lt;/li&gt;
  &lt;li&gt;Memory allocation&lt;/li&gt;
  &lt;li&gt;Garbage collection&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;memory-performance-and-garbage-collection&quot;&gt;Memory Performance and Garbage Collection&lt;/h2&gt;
&lt;h3 id=&quot;memory-management-in-os-and-application-level&quot;&gt;Memory Management in OS and Application Level&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;memory allocation 内存分配&lt;/li&gt;
  &lt;li&gt;garbage collection 垃圾回收&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;object-model-内存对象模型&quot;&gt;Object Model 内存对象模型&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Create a new object x&lt;/li&gt;
  &lt;li&gt;Attach it to the reference x;&lt;/li&gt;
  &lt;li&gt;Initialize its fields.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;three-modes-of-object-management&quot;&gt;Three modes of object management&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Static mode ——在编译阶段就已经确定好了内存分配&lt;/li&gt;
  &lt;li&gt;Dynamic allocation
    &lt;ul&gt;
      &lt;li&gt;Stack-based mode
        &lt;ul&gt;
          &lt;li&gt;存储方法调和局部变量&lt;/li&gt;
          &lt;li&gt;多线程之间传递数据，是通过复制而非引用局部的基本数据类型&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
      &lt;li&gt;Heap-based mode  (free mode)
        &lt;ul&gt;
          &lt;li&gt;在一块内存里分为多个小块，每块包含 一个对象，或者未被占用&lt;/li&gt;
          &lt;li&gt;所有对象&lt;/li&gt;
          &lt;li&gt;即使是局部变量的object，也是在堆上创建&lt;/li&gt;
          &lt;li&gt;堆上创建的对象可被所有线程共享引用&lt;/li&gt;
        &lt;/ul&gt;
      &lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;java-memory-model&quot;&gt;Java Memory Model&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Thread Stack — All local variables of primitive types&lt;/li&gt;
  &lt;li&gt;Heap — All objects&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;memory-structure-of-jvm&quot;&gt;Memory Structure of JVM&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;Stacks
    &lt;ul&gt;
      &lt;li&gt;Reference/Local variable&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Heap
    &lt;ul&gt;
      &lt;li&gt;Object/Value&lt;/li&gt;
      &lt;li&gt;An object’s primitive member variables&lt;/li&gt;
      &lt;li&gt;a member variable is a reference to an objectf&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Native Stacks 本地方法栈
    &lt;ul&gt;
      &lt;li&gt;manage native methods (coded in C) used by JVM&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Program Counter Register (PC)
    &lt;ul&gt;
      &lt;li&gt;代码行号指示器，用于指示， 跳转下一条需要执行的命令&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;Method Area
    &lt;ul&gt;
      &lt;li&gt;用于存储被VM加载的类信息、常量、静态变量等 class Static variable&lt;/li&gt;
      &lt;li&gt;HotSpot JVM中用Permanent Area (Perm)实现该区域，并作为heap的一部分&lt;/li&gt;
      &lt;li&gt;Java 8之后改名为Metaspace (使用native memory)&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;garbage-collection&quot;&gt;Garbage Collection&lt;/h3&gt;
&lt;ol&gt;
  &lt;li&gt;static modes
无需进行内存回收:所有都是已确定的&lt;/li&gt;
  &lt;li&gt;stack-based modes
在栈上进行内存空间回收:按block(某个方法)整体进行&lt;/li&gt;
  &lt;li&gt;heap-based (free) modes
    &lt;ul&gt;
      &lt;li&gt;Reachable Objects vs. Unreachable Objects — Live vs. Dead &lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;从root对象开始进行有向图的搜索，将图分为root可达部分和root不可达部分 &lt;br /&gt;&lt;/li&gt;
      &lt;li&gt;&lt;strong&gt;roots&lt;/strong&gt; 包括：&lt;br /&gt;
1) Words in the static area 静态区域的数据&lt;br /&gt;
2) Registers 寄存器&lt;br /&gt;
3) Words on the execution stack that point into the heap. 目前的执行栈中的数据所指向的内存对象&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&quot;help-the-gc-that-you-are-finished-with-an-object&quot;&gt;Help the GC that you are finished with an object&lt;/h4&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;r = new FileReader(filename)
// use the reader
...
reader.close();
reader = null;
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h4 id=&quot;without-automatic-gc&quot;&gt;Without Automatic GC&lt;/h4&gt;
&lt;p&gt;内存泄露，很多dead objects仍占据着内存空间 &lt;br /&gt;
原本live的对象却被回收了 (Dangling Pointers 悬空指针)，导致程序执行失效。&lt;/p&gt;

&lt;hr /&gt;
&lt;h2 id=&quot;basic-algorithms-of-garbage-collection&quot;&gt;Basic Algorithms of Garbage Collection&lt;/h2&gt;
&lt;h3 id=&quot;reference-counting-引用计数&quot;&gt;Reference counting 引用计数&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;为每个object存储一个计数RC，当有其他 reference指向它时，RC++;当其他reference与其断开时，RC–;如 果RC==0，则回收它 (及其所有指向的object)。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Advantages&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;简单&lt;/li&gt;
  &lt;li&gt;计算代价分散&lt;/li&gt;
  &lt;li&gt;“幽灵时间”短-&amp;gt;0&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Disadvantages&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;不全面(容易漏掉循环引用的对象cyclic)&lt;/li&gt;
  &lt;li&gt;并发支持较弱&lt;/li&gt;
  &lt;li&gt;占用额外内存空间等&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mark-sweep-标记-清除&quot;&gt;Mark-Sweep 标记-清除&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;标记-清除:为每个object设定状态位(live/dead)并记录，即mark阶段;将标记为dead的对象进行清理，即sweep阶段。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Disadvantages&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;需要停止程序执行来Mark和Sweep，导致幽灵时间过长，也影响程序本身的性能&lt;/li&gt;
  &lt;li&gt;碎片化&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;mark-compact-标记-整理&quot;&gt;Mark-Compact 标记-整理&lt;/h3&gt;
&lt;p&gt;Advantages&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;避免碎片化&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Disadvantages&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;时间消耗太长，影响程序本身&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fragmentation-and-copying-复制&quot;&gt;Fragmentation and Copying 复制&lt;/h3&gt;

&lt;blockquote&gt;
  &lt;p&gt;该GC策略与mark-compact的区别在于:不是在同一个区域内进行整理，而是将live对象全部复制到另一个区域。&lt;br /&gt; 将堆分为两部分 Fromspace and Tospace&lt;/p&gt;
&lt;/blockquote&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;garbage-collection-in-jvm&quot;&gt;Garbage Collection in JVM&lt;/h2&gt;
&lt;p&gt;Java GC将堆分为不同的区域，各区域采用不同的GC策略，以提高GC的效率&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;-verbose:gc
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h3 id=&quot;three-major-space-in-hotspot-vm-sun-jvm&quot;&gt;Three major space in HotSpot VM (Sun JVM)&lt;/h3&gt;
&lt;h4 id=&quot;young-generation&quot;&gt;young generation&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;Eden&lt;/li&gt;
  &lt;li&gt;From survivor space&lt;/li&gt;
  &lt;li&gt;To survivor space&lt;/li&gt;
  &lt;li&gt;只有一小部分对象可较长时间存活，故采用&lt;strong&gt;copy&lt;/strong&gt;算法减少GC代价&lt;/li&gt;
  &lt;li&gt;使用&lt;strong&gt;minor GC&lt;/strong&gt;进行垃圾收集&lt;/li&gt;
  &lt;li&gt;Minor GC所需时间较短&lt;/li&gt;
  &lt;li&gt;如果历经多次minor GC仍存活下来，将其copy到old generation&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;old-generation-space-tenured&quot;&gt;old generation space (tenured)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;这里的对象有很高的幸存度，使用&lt;strong&gt;Mark-Sweep&lt;/strong&gt;或&lt;strong&gt;Mark-Compact&lt;/strong&gt;算法&lt;/li&gt;
  &lt;li&gt;启动&lt;strong&gt;full GC&lt;/strong&gt;&lt;/li&gt;
  &lt;li&gt;Old generation满，意味着无法进行下一次minor GC&lt;/li&gt;
  &lt;li&gt;Minor GC和full GC独立进行，减小代价&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;permanent-generation-space-perm&quot;&gt;Permanent generation space (perm)&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;当perm generation满了之后，无法存储更多的元数据，也启动full GC&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;只有当某个区域不能再为对象分配内存时(满)才启动GC
&lt;code class=&quot;highlighter-rouge&quot;&gt;java.lang.OutOfMemoryError&lt;/code&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;garbage-collection-tuning-in-jvm&quot;&gt;Garbage Collection Tuning in JVM&lt;/h2&gt;
&lt;h3 id=&quot;specifying-vm-heap-size-确定堆的大小&quot;&gt;Specifying VM heap size 确定堆的大小&lt;/h3&gt;
&lt;h4 id=&quot;控制young-generation的大小&quot;&gt;控制Young generation的大小&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;-XX: NewSize=&lt;n&gt;[g|m|k]&lt;/n&gt;&lt;/li&gt;
  &lt;li&gt;-XX: MaxNewSize=&lt;n&gt;[g|m|k]&lt;/n&gt;&lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;-Xmn&lt;n&gt;[g|m|k]
-三个参数依次为最小值、最大值和固定值。&lt;/n&gt;&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;-Xms and -Xmx 初始和最大的heap尺寸
heap尺寸变化时需 要full GC&lt;/li&gt;
  &lt;li&gt;-XX:MetaspaceSize -XX:MaxMetaspaceSize for Java 8 and later&lt;/li&gt;
  &lt;li&gt;-XX:SurvivorRatio=&lt;n&gt;&lt;/n&gt;&lt;/li&gt;
  &lt;li&gt;-XX:NewRatio=&lt;n&gt; --- young and old generation is 1:n&lt;/n&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;old generation的尺寸不需要设置，根据其他各参数的取值可计算得到&lt;/p&gt;

&lt;h3 id=&quot;choosing-a-garbage-collection-scheme-选择gc模式&quot;&gt;Choosing a garbage collection scheme 选择GC模式&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;-XX:+UseSerialGC：使用单线程GC。&lt;/li&gt;
  &lt;li&gt;-XX:+UseParallelGC：对MinorGC使用多线程进行回收，但对MajorGC仍采用单线程。&lt;/li&gt;
  &lt;li&gt;-XX:+UseConcMarkSweepGC：与程序的运行同步地进行垃圾回收，回收时会短暂地暂停程序。&lt;/li&gt;
  &lt;li&gt;-XX:+UseTrainGC：每次MinorGC回收一部分老年代对象，以尝试最小化MajorGC的长时暂停。
    &lt;h4 id=&quot;garbage-first-collector&quot;&gt;Garbage-First collector&lt;/h4&gt;
    &lt;blockquote&gt;
      &lt;p&gt;designed for heap sizes greater than 4GB. It divides the heap size into regions. After the marking phase is complete, G1 collects the region with lesser live data, which usually yields a large amount of free space. So G1 collects these regions first.
&lt;br /&gt;Default in Java 9.&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Automatically logging low memory conditions 自动记录内存将要不足的情况&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;-Xloggc:../../logs/gc-console.log&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Manually requesting garbage collection 手工请求GC&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;System.gc()&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;io-and-algorithm-performance&quot;&gt;I/O and Algorithm Performance&lt;/h2&gt;
&lt;h3 id=&quot;buffer对数据进行缓冲&quot;&gt;Buffer：对数据进行缓冲&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;BufferedReader&lt;/li&gt;
  &lt;li&gt;BufferedWriter&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;stream将数据视作流&quot;&gt;Stream：将数据视作流&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;FileInputStream&lt;/li&gt;
  &lt;li&gt;FileOutputStream&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;nionew-io&quot;&gt;NIO：New I/O&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Buffers（包括CharBuffer、ByteBuffer、IntBuffer、DoubleBuffer等）&lt;/li&gt;
  &lt;li&gt;Channels（包括FileChannel、SockerChannel等，可向Buffer提供数据）&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lamda&quot;&gt;Lamda&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Files.lines(Paths.get(args[0])).forEach(System.out::println);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;dynamic-program-analysis-methods-and-tools&quot;&gt;Dynamic Program Analysis Methods and Tools&lt;/h2&gt;
&lt;h3 id=&quot;80-20-rule&quot;&gt;80-20 rule&lt;/h3&gt;
&lt;p&gt;20% of program responsible for 80% of execution time&lt;/p&gt;
&lt;h3 id=&quot;dynamic-program-analysis&quot;&gt;Dynamic Program Analysis&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Program Hot Spots — 每个程序实体 (语句、分支、路径、方法等)的执行概率/频度是多少&lt;/li&gt;
  &lt;li&gt;Path profiling&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;profiling-approaches&quot;&gt;Profiling Approaches&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Insertion/Instrumentation 代码注入/代码插入&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;在原始程序中加入某些语句来收集运行时数据，这些语句不改变原程序的语义，但对原程序的性能有了轻微变化&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Sampling: observation of behavior 采样&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;以特定的频率观察程序执行的特定时刻所展现出的行为与状态&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Instrumented virtual machine 借助于虚拟机获取程序性能数据&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;program-profiling-tools-in-java&quot;&gt;Program Profiling Tools in Java&lt;/h3&gt;

&lt;ul&gt;
  &lt;li&gt;Command-line profiling tools
    &lt;ul&gt;
      &lt;li&gt;jhat — 在Web浏览器中查看heap dump文件的内容&lt;/li&gt;
      &lt;li&gt;jmap — jmap -dump 生成 java heap dump&lt;/li&gt;
      &lt;li&gt;jstat&lt;/li&gt;
      &lt;li&gt;jstack — 打印 stack traces&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;JConsole&lt;/li&gt;
  &lt;li&gt;Visual VM&lt;/li&gt;
  &lt;li&gt;Memory Analyzer (MAT) — 显示堆转储的内容分析&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;h2 id=&quot;code-tuning-for-performance-optimization&quot;&gt;Code Tuning for Performance Optimization&lt;/h2&gt;
&lt;h3 id=&quot;java代码调优的设计模式&quot;&gt;Java代码调优的设计模式&lt;/h3&gt;
&lt;h4 id=&quot;singleton-pattern&quot;&gt;Singleton Pattern&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;逻辑上仅能存在唯一一个实例，为了防止多个该对象实例被创建，将构造方法设为私有，并提供获取该类唯一实例的方法（ &lt;code class=&quot;highlighter-rouge&quot;&gt;getInstance()&lt;/code&gt; ）&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;static final instance
    &lt;blockquote&gt;
      &lt;p&gt;设置静态变量来存储单一实例对象&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;private constructor
    &lt;blockquote&gt;
      &lt;p&gt;将构造器设置为private，从而client无法new &lt;br /&gt;  在构造器中new新实例&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
  &lt;li&gt;static getInstance()
    &lt;blockquote&gt;
      &lt;p&gt;提供静态方法来获取单一实例对象 &lt;br /&gt;  进一步提升性能:在需要的时候再new，而非提前构造&lt;/p&gt;
    &lt;/blockquote&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;flyweight-pattern&quot;&gt;Flyweight Pattern&lt;/h3&gt;
&lt;blockquote&gt;
  &lt;p&gt;当某对象由大量对象组成，而部分Flyweight对象可被共享以减少资源消耗时，可创建一个工厂类以方便外界获得可被共享的对象，对于目前不存在的ConcreteFlyweight对象，工厂类会创建之，而对于已存在的ConcreteFlyweight对象，工厂类会直接返回之。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;固定 — 内部rep&lt;/li&gt;
  &lt;li&gt;可变 — 外部特征&lt;/li&gt;
  &lt;li&gt;Immutable&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;prototype-pattern-cloneable&quot;&gt;Prototype Pattern /cloneable&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;当需要客户端指定要创建的对象的类型，且之后需创建的对象与先前指定的完全相同时，可通过给出第一个对象（称为原型对象）以指明之后所有对象的类型，之后所有对象通过复制第一个对象来创建。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;implement &lt;code class=&quot;highlighter-rouge&quot;&gt;Cloneable&lt;/code&gt;, override &lt;code class=&quot;highlighter-rouge&quot;&gt;clone()&lt;/code&gt;&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;reference copy — shallow copy&lt;/li&gt;
  &lt;li&gt;object copy — deep copy&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;object-pool-pattern&quot;&gt;Object Pool Pattern&lt;/h4&gt;
&lt;blockquote&gt;
  &lt;p&gt;当某类对象（图中为Object类对象）的创建代价极大，而该类对象可以以较小的代价被重复利用时，可以预先建立一个对象池用于保存该类对象。对象池中可预先创建几个对象等待使用，使用完的对象会回到对象池中被重新初始化并被再利用，减少对象的创建操作。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;代价:原本可被GC的对象，现在要留在pool中，导致内存浪费 —— 用空间换时间&lt;/p&gt;
&lt;h4 id=&quot;canonicalizing-objects&quot;&gt;Canonicalizing Objects&lt;/h4&gt;

&lt;h3 id=&quot;string-constant-pool&quot;&gt;String Constant Pool&lt;/h3&gt;
&lt;p&gt;堆中包含字符串对象引用的特殊内存区域&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;String s = “java”;
String s = new String(“java”);
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
</description>
        <pubDate>Thu, 20 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/Performance.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/Performance.html</guid>
        
        <category>CODE</category>
        
        <category>SOFTWARECONSTRUCTION</category>
        
        <category>JAVA</category>
        
        
        <category>coding</category>
        
      </item>
    
      <item>
        <title>软件构造课程总结——并行与分布式程序</title>
        <description>&lt;h2 id=&quot;concurrency&quot;&gt;Concurrency&lt;/h2&gt;
&lt;h3 id=&quot;two-models-for-concurrent-programming&quot;&gt;Two Models for Concurrent Programming&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Shared memory — 并发模块通过在内存中读写共享对象进行交互。&lt;/li&gt;
  &lt;li&gt;Message passing — sending messages to each other through a communication channel. Modules send off messages, and incoming messages to each module are queued up for handling.&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;应用&quot;&gt;应用&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;网络上的两台计算机通过网络连接通讯&lt;/li&gt;
  &lt;li&gt;浏览器和Web服务器，A请求页面，B发送页面数据给A&lt;/li&gt;
  &lt;li&gt;即时通讯软件的客户端和服务器&lt;/li&gt;
  &lt;li&gt;同一台计算机上的两个程序通过管道连接进行通讯&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;process--thread&quot;&gt;Process &amp;amp; Thread&lt;/h2&gt;
&lt;h3 id=&quot;process&quot;&gt;Process&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在同一机器上独立于其它进程的一个运行中程序的实例。它拥有自己独立的内存空间。可视为一台虚拟机。&lt;/li&gt;
  &lt;li&gt;拥有整台计算机的资源&lt;/li&gt;
  &lt;li&gt;私有空间 彼此隔离 不共享内存&lt;/li&gt;
  &lt;li&gt;通过消息传递进行协作&lt;/li&gt;
  &lt;li&gt;JVM通常运行单一进程，但也可以创建新的进程&lt;/li&gt;
  &lt;li&gt;共享可变对象时需要同步&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;thread&quot;&gt;Thread&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;一个运行中程序的控制轨迹，每个线程在程序中某个位置执行，拥有自己独立的运行时栈。可视为一个虚拟处理器。&lt;/li&gt;
  &lt;li&gt;共享内存 消息队列&lt;/li&gt;
  &lt;li&gt;轻量级&lt;/li&gt;
  &lt;li&gt;共享可变对象时需要同步&lt;/li&gt;
  &lt;li&gt;unsafe to kill&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;new-thread&quot;&gt;new Thread&lt;/h4&gt;

&lt;ul&gt;
  &lt;li&gt;(Seldom used) Subclassing Thread.
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyThread extends Thread {
@Override
public void run() {
  ...
}
}
(new MyThread()).start();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;(new MyThread()).run();可运行，未启动线程
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
  &lt;li&gt;(More generally used) 从Runnable接口构造Thread对象
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;new Thread(new Runnable() {
 public void run() {
     System.out.println(&quot;Hello&quot;);
 }
}).start();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
    &lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;class MyThread implements Runnable {
@Override
public void run() {
  ...
}
(new Thread(new MyThread())).start();
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;    &lt;/div&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;heisenbugs&quot;&gt;Heisenbugs&lt;/h3&gt;
&lt;p&gt;Nondeterministic and hard to reproduce &lt;br /&gt;
A heisenbug may even disappear when you try to look at it with println or debugger&lt;/p&gt;
&lt;h3 id=&quot;bohrbugs&quot;&gt;Bohrbugs&lt;/h3&gt;
&lt;p&gt;Showing up repeatedly whenever you look at it.&lt;/p&gt;
&lt;h2 id=&quot;interleaving-and-race-condition&quot;&gt;Interleaving and Race Condition&lt;/h2&gt;
&lt;h3 id=&quot;time-slicing&quot;&gt;Time slicing&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在单核计算机中，每一时刻仅有一个线程在实际运行。单个核心的运行时间通过操作系统的特性被各个进程和线程共享，这种行为称为时间分片。&lt;/li&gt;
  &lt;li&gt;在多核计算机中，当线程数大于核心数时，也通过时间分片来模拟线程并行运行。&lt;/li&gt;
  &lt;li&gt;时间切片不可预测、不确定，这意味着线程可以随时暂停或恢复&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;shared-memory-among-threads&quot;&gt;Shared Memory among Threads&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Interleaving 交叉存取 — 当两线程并行运行时，底层指令可能交错运行&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;race-condition&quot;&gt;Race Condition&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;The correctness of the program (the satisfaction of postconditions and invariants) depends on the relative timing of events in concurrent computations A and B. When this happens, we say “A is in a race with B.”&lt;/li&gt;
  &lt;li&gt;单行、单条语句都未必是原子的。是否原子由JVM确定&lt;/li&gt;
  &lt;li&gt;also called “Thread Interference”&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;some-operations-for-interfering-automatic-interleaving-of-threads&quot;&gt;Some operations for interfering automatic interleaving of threads&lt;/h2&gt;
&lt;h3 id=&quot;threadsleep&quot;&gt;Thread.sleep()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;不会失去对现有monitor锁的所有权&lt;/li&gt;
  &lt;li&gt;在sleep()的时候检测是否收到别人的中断信号, catch(IntterruptedException e)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;threadinterrupt&quot;&gt;Thread.interrupt()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;t.interrupt()&lt;/li&gt;
  &lt;li&gt;t.isInterrupted()
-正常运行期间，即使受到中断信号也不理会&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;threadyield-避免使用&quot;&gt;Thread.yield() (避免使用)&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;线程会告诉调度器可以放弃CPU的占用权, 从而可能引起调度器唤醒其他线程&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;threadjoin&quot;&gt;Thread.join()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;让当前线程保持执行，直到其执行结束&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;objectwait&quot;&gt;object.wait()&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;使用前提为线程已获得被调用对象的对象锁。当前线程放弃对象锁并进入等待状态，直到其它获得该对象锁的线程对该对象调用notify()或notifyAll()方法。当前线程被通知或被中断时，尝试重新获得锁并继续运行。若被中断，InterruptedException将在获得对象锁之后抛出。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;thread-safety&quot;&gt;Thread Safety&lt;/h2&gt;
&lt;h3 id=&quot;confinement&quot;&gt;Confinement&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Don’t share: isolate mutable state in individual threads&lt;/li&gt;
  &lt;li&gt;将可变数据限制在单一线程内部，避免竞争&lt;/li&gt;
  &lt;li&gt;不允许任何线程直接读写该数据&lt;/li&gt;
  &lt;li&gt;避免全局变量 如Singleton设计模式 两个线程同时调用getInstance()违背设计&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;immutability&quot;&gt;Immutability&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Don’t mutate: share only immutable state&lt;/li&gt;
  &lt;li&gt;共享不可变的引用和数据类型&lt;/li&gt;
  &lt;li&gt;如果使用了beneficent mutation还是要加锁&lt;/li&gt;
  &lt;li&gt;不含mutator方法&lt;/li&gt;
  &lt;li&gt;所有字段必须被private final修饰&lt;/li&gt;
  &lt;li&gt;子类不可重写方法&lt;/li&gt;
  &lt;li&gt;没有表示泄露&lt;/li&gt;
  &lt;li&gt;表示中的可变对象不得变化&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;using-threadsafe-data-types&quot;&gt;Using Threadsafe Data Types&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;Threadsafe Collections&lt;/li&gt;
  &lt;li&gt;private static Map&amp;lt;Integer,Boolean&amp;gt; cache = Collections.synchronizedMap(new HashMap&amp;lt;&amp;gt;());&lt;/li&gt;
  &lt;li&gt;多个操作间不保证安全 如(!list.isEmpty()) list.get(0)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;locks-and-synchronization&quot;&gt;Locks and Synchronization&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;在使用synchronizedMap(hashMap)之后，不要再把参数hashMap共享给其他线程，不要保留别名，一定要彻底销毁&lt;/li&gt;
  &lt;li&gt;即使在线程安全的集合类上，使用iterator也是不安全的（除非使用lock机制）&lt;/li&gt;
  &lt;li&gt;即使是线程安全的collection类，仍可能产生竞争&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;volatile&quot;&gt;Volatile&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;volatile也可保证基本类型变量变化对于所有线程的可见性（同步缓存），但不一定保证操作的原子性。&lt;/li&gt;
  &lt;li&gt;当且仅当对volatile修饰的变量进行的修改与任何变量（包括自身）的值无关时，其才是线程安全的。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;线程安全策略撰写&quot;&gt;线程安全策略撰写&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;采取了四种方法中的哪一种&lt;/li&gt;
  &lt;li&gt;如果是后两种，还需考虑对数据的访问 都是原子的，不存在interleaving&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;confinement-1&quot;&gt;Confinement&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;局限访问策略通常不适用于仅仅讨论一个数据类型的情况，因为你需要知道系统中存在哪些线程，每个线程可访问哪些对象。&lt;/li&gt;
  &lt;li&gt;若访问该数据类型的线程均由自身创建，则可讨论这些线程间如何保持访问的局限性&lt;/li&gt;
  &lt;li&gt;若线程来自于外部，则无法讨论&lt;/li&gt;
  &lt;li&gt;通常在将系统作为一个整体，讨论一些模块或数据类型不需要线程安全的原因时，会从设计的角度论证线程间不会共享数据。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;immutability-1&quot;&gt;Immutability&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;说明对象中数据为何能够保持不可变性即可&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;using-threadsafe-data-types-1&quot;&gt;Using Threadsafe Data Types&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;表明该数据类型的所有原子操作都被恰当地设计，使得该数据类型依赖的不变式不受原子操作的交错执行影响。&lt;/li&gt;
  &lt;li&gt;nodes和edges举例&lt;/li&gt;
&lt;/ul&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;private final Set&amp;lt;Node&amp;gt; nodes = Collections.synchronizedSet(new HashSet&amp;lt;&amp;gt;());
private final Map&amp;lt;Node,Set&amp;lt;Node&amp;gt;&amp;gt; edges = Collections.synchronizedMap(new HashMap&amp;lt;&amp;gt;());
// 表示不变式：
// 对于所有满足y是edges.get(x)的成员的二元组x和y，x,y都是nodes的成员。
该类是线程安全的，因为：nodes和edges都声明为final，因此它们都是不可变的且是线程安全的。
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;blockquote&gt;
  &lt;p&gt;nodes和edges都指向线程安全的Set和Map数据类型。
该论证仅防止了某些竞争条件，但不是全部。由于该类的表示不变式中要求了nodes与edges成员间的关系，因此还应论证两者成员的改变应当是同时的、原子的。若该点无法证明，则可以构造竞争条件。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h4 id=&quot;locks-and-synchronization-1&quot;&gt;Locks and Synchronization&lt;/h4&gt;
&lt;ul&gt;
  &lt;li&gt;表明该数据类型的所有原子操作都被恰当地设计，使得该数据类型依赖的不变式不受原子操作的交错执行影响。&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;locks-and-synchronization-2&quot;&gt;Locks and Synchronization&lt;/h2&gt;
&lt;h3 id=&quot;monitor模式adt所有方法都是互斥访问&quot;&gt;Monitor模式:ADT所有方法都是互斥访问&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;reads must be guarded as well as writes&lt;/li&gt;
  &lt;li&gt;public synchronized void fun(){…} == synchronized(this)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;fine-grained-synchronization&quot;&gt;fine-grained synchronization.&lt;/h3&gt;
&lt;p&gt;synchronized(object)&lt;/p&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;public synchronized Constructor(){
  ...
} // wrong
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;
&lt;ul&gt;
  &lt;li&gt;用ADT自己做lock&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;lock&quot;&gt;Lock&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;div class=&quot;highlight&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;Object lock = new Object();
synchronized (lock) {
  ...
}
&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;

&lt;h2 id=&quot;liveness&quot;&gt;Liveness&lt;/h2&gt;
&lt;h3 id=&quot;deadlock&quot;&gt;Deadlock&lt;/h3&gt;
&lt;p&gt;多个线程竞争lock，相互等待对方释放lock&lt;/p&gt;

&lt;h4 id=&quot;解决方案&quot;&gt;解决方案：&lt;/h4&gt;

&lt;ol&gt;
  &lt;li&gt;两线程均按顺序征用锁-两个线程均先获得A锁再获得B锁
    &lt;ul&gt;
      &lt;li&gt;缺点1:不是模块化的——代码必须知道系统中的所有锁，或者至少知道子系统中的所有锁&lt;/li&gt;
      &lt;li&gt;缺点2:代码可能很难或不可能在获取第一个锁之前准确地知道它需要哪些锁 &lt;br /&gt;&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
  &lt;li&gt;粗粒度的lock
    &lt;ul&gt;
      &lt;li&gt;缺点：性能下降&lt;/li&gt;
    &lt;/ul&gt;
  &lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&quot;starvation&quot;&gt;Starvation&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;因为其他线程lock时间太长，一个线程长时间无法获取其所需的资源访问权(lock)，导致无法往下进行&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;livelock&quot;&gt;Livelock&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;两线程的行为互相由对方的行为决定（通常是为了避免死锁），线程没有锁死，仍在正常运行，但无法正常工作。&lt;/li&gt;
&lt;/ul&gt;
</description>
        <pubDate>Tue, 18 Jun 2019 00:00:00 +0800</pubDate>
        <link>http://localhost:4000/coding/Concurrent-and-Distributed-Programming.html</link>
        <guid isPermaLink="true">http://localhost:4000/coding/Concurrent-and-Distributed-Programming.html</guid>
        
        <category>SOFTWARE-CONSTRUCTION</category>
        
        <category>JAVA</category>
        
        
        <category>coding</category>
        
      </item>
    
  </channel>
</rss>
